
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_8__ TYPE_2__ ;
typedef struct TYPE_7__ TYPE_1__ ;


struct TYPE_8__ {char* name; int value; struct TYPE_8__* next; } ;
struct TYPE_7__ {scalar_t__ len; int data; } ;
typedef TYPE_1__ StringInfoData ;
typedef TYPE_2__ ConfigVariable ;


 scalar_t__ ENOSPC ;
 int ERRCODE_OUT_OF_MEMORY ;
 int ERROR ;
 int appendStringInfoString (TYPE_1__*,char*) ;
 int ereport (int ,int ) ;
 int errcode (int ) ;
 int errcode_for_file_access () ;
 int errmsg (char*,...) ;
 scalar_t__ errno ;
 char* escape_single_quotes_ascii (int ) ;
 int free (char*) ;
 int initStringInfo (TYPE_1__*) ;
 int pfree (int ) ;
 scalar_t__ pg_fsync (int) ;
 int resetStringInfo (TYPE_1__*) ;
 scalar_t__ write (int,int ,scalar_t__) ;

__attribute__((used)) static void
write_auto_conf_file(int fd, const char *filename, ConfigVariable *head)
{
 StringInfoData buf;
 ConfigVariable *item;

 initStringInfo(&buf);


 appendStringInfoString(&buf, "# Do not edit this file manually!\n");
 appendStringInfoString(&buf, "# It will be overwritten by the ALTER SYSTEM command.\n");

 errno = 0;
 if (write(fd, buf.data, buf.len) != buf.len)
 {

  if (errno == 0)
   errno = ENOSPC;
  ereport(ERROR,
    (errcode_for_file_access(),
     errmsg("could not write to file \"%s\": %m", filename)));
 }


 for (item = head; item != ((void*)0); item = item->next)
 {
  char *escaped;

  resetStringInfo(&buf);

  appendStringInfoString(&buf, item->name);
  appendStringInfoString(&buf, " = '");

  escaped = escape_single_quotes_ascii(item->value);
  if (!escaped)
   ereport(ERROR,
     (errcode(ERRCODE_OUT_OF_MEMORY),
      errmsg("out of memory")));
  appendStringInfoString(&buf, escaped);
  free(escaped);

  appendStringInfoString(&buf, "'\n");

  errno = 0;
  if (write(fd, buf.data, buf.len) != buf.len)
  {

   if (errno == 0)
    errno = ENOSPC;
   ereport(ERROR,
     (errcode_for_file_access(),
      errmsg("could not write to file \"%s\": %m", filename)));
  }
 }


 if (pg_fsync(fd) != 0)
  ereport(ERROR,
    (errcode_for_file_access(),
     errmsg("could not fsync file \"%s\": %m", filename)));

 pfree(buf.data);
}
