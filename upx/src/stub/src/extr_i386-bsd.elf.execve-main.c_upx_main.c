
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_4__ TYPE_2__ ;
typedef struct TYPE_3__ TYPE_1__ ;


typedef int uint32_t ;
typedef int tmpname_buf ;
struct TYPE_3__ {scalar_t__ tv_usec; scalar_t__ tv_sec; } ;
struct timex {scalar_t__ errcnt; TYPE_1__ time; } ;
struct timeval {scalar_t__ tv_usec; scalar_t__ tv_sec; } ;
struct timespec {scalar_t__ tv_nsec; int tv_sec; } ;
struct p_info {scalar_t__ p_progid; int p_filesize; int p_blocksize; } ;
struct b_info {scalar_t__ sz_unc; scalar_t__ sz_cpr; int b_method; } ;
struct Extent {char* buf; scalar_t__ size; } ;
typedef scalar_t__ nrv_uint ;
typedef int header ;
typedef int h ;
typedef int f_unfilter ;
typedef int (* f_expand ) (unsigned char*,scalar_t__,unsigned char*,scalar_t__*,int) ;
struct TYPE_4__ {scalar_t__ ma_length; } ;


 int ENOENT ;
 int MAP_ANONYMOUS ;
 int MAP_FIXED ;
 int MAP_PRIVATE ;
 int MAP_SHARED ;
 int OVERHEAD ;
 int O_CREAT ;
 int O_EXCL ;
 int O_RDWR ;
 int O_WRONLY ;
 int PAGE_MASK ;
 int PROT_READ ;
 int PROT_WRITE ;
 int SET4 (char*,char,unsigned char,char,char) ;
 scalar_t__ UPX3 ;
 int UPX4 ;
 scalar_t__ UPX_MAGIC_LE32 ;
 int adjtimex (struct timex*) ;
 int ascii5 (char*,int,int) ;
 scalar_t__ close (int) ;
 int execve (char*,char const* const*,char const* const*) ;
 int exit (int) ;
 scalar_t__ fork () ;
 scalar_t__ ftruncate (int,int) ;
 scalar_t__ getpid () ;
 int gettimeofday (struct timeval*,int ) ;
 scalar_t__ go_self (char*,char**,char**) ;
 TYPE_2__ malloc_args ;
 unsigned char* mmap (unsigned char*,int,int,int,int,int ) ;
 int munmap (unsigned char*,scalar_t__) ;
 int nanosleep (struct timespec*,int ) ;
 int open (char*,int,int) ;
 int stub1 (unsigned char*,scalar_t__,unsigned char*,scalar_t__*,int) ;
 int unlink (char*) ;
 int waitpid (int,int*,int ) ;
 scalar_t__ xwrite (int,unsigned char*,scalar_t__) ;

void upx_main(
    struct Extent xi,
    f_expand *const f_decompress,
    int junk,
    f_unfilter *const f_unf,
    char *envp[],
    char *argv[],
    int argc
)
{

    int fdo;


    unsigned char *buf;

    char *tmpname;
    struct p_info header;


    char tmpname_buf[20];

    (void)junk;
    {
        register char *__d0, *__d1;
        __asm__ __volatile__( "movsl; movsl; movsl"
            : "=&D" (__d0), "=&S" (__d1)
            : "0" (&header), "1" (xi.buf)
            : "memory");
        xi.buf = __d1;
        xi.size -= sizeof(header);
    }




    if (header.p_progid != UPX3)
        goto error1;






    tmpname = tmpname_buf;
    SET4(tmpname + 0, '/', 't', 'm', 'p');
    SET4(tmpname + 4, '/', 'u', 'p', 'x');



    {
        char *p = tmpname_buf + sizeof(tmpname_buf) - 1;


        uint32_t r = ascii5(p, (uint32_t)getpid(), 4); *p = '\0'; p -= 4;


        r ^= header.p_progid;


        {

            struct timeval tv;
            gettimeofday(&tv, 0);
            r ^= (uint32_t) tv.tv_sec;
            r ^= ((uint32_t) tv.tv_usec) << 12;
        }

        ascii5(p, r, 7);
    }


    {
        int err = unlink(tmpname);
        if (err != -ENOENT && err != 0)
            goto error1;
    }





    fdo = open(tmpname, O_WRONLY | O_CREAT | O_EXCL, 0700);
    if (ftruncate(fdo, header.p_filesize) != 0)
        goto error;
    buf = mmap(0, (header.p_blocksize + OVERHEAD + ~PAGE_MASK) & PAGE_MASK,
        PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0 );
    if ((unsigned long) buf >= (unsigned long) -4095)
        goto error;






    for (;;)
    {
        struct b_info h;


        {
            register char *__d0, *__d1;
            __asm__ __volatile__( "movsl; movsl; movsl"
                : "=&D" (__d0), "=&S" (__d1)
                : "0" (&h), "1" (xi.buf)
                : "memory");
            xi.buf = __d1;
            xi.size -= sizeof(h);
        }
        if (h.sz_unc == 0)
        {
            if (h.sz_cpr != UPX_MAGIC_LE32)
                goto error;
            if (header.p_filesize != 0)
                goto error;
            break;
        }



        if (h.sz_cpr > h.sz_unc || h.sz_cpr > header.p_blocksize)
            goto error;





        if (h.sz_cpr < h.sz_unc) {
            nrv_uint out_len = h.sz_unc;
            int i = (*f_decompress)((unsigned char *)xi.buf, h.sz_cpr, buf,
                &out_len, *(int *)(void *)&h.b_method);
            if (i != 0 || out_len != (nrv_uint)h.sz_unc)
                goto error;


            (void)f_unf;
        }
        else
        {
        }







        if (xwrite(fdo, buf, h.sz_unc) != 0)
            goto error;


        header.p_filesize -= h.sz_unc;

        xi.buf += h.sz_cpr;
        xi.size -= h.sz_cpr;

        if (xi.size < 0) {

        error:
            (void) unlink(tmpname);
        error1:


            for (;;)
                (void) exit(127);
        }
    }
    munmap(buf, malloc_args.ma_length);


    if (close(fdo) != 0)
        goto error;
    if (0 > go_self(tmpname, argv, envp))
        goto error;
    if (fork() == 0)
    {
        if (fork() == 0)
        {

            struct timespec ts; ts.tv_sec = UPX4; ts.tv_nsec = 0;
            nanosleep(&ts, 0);
            unlink(tmpname);
        }
        exit(0);
    }


    waitpid(-1, (int *)0, 0);


    (void)argc;
    execve(tmpname, (char const *const *)argv, (char const *const *)envp);







    goto error;
}
