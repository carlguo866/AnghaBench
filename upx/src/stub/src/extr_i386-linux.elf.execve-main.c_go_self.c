
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;
 int FD_CLOEXEC ;
 int F_SETFD ;
 int MAP_PRIVATE ;
 int O_CREAT ;
 int O_EXCL ;
 int O_RDONLY ;
 int O_WRONLY ;
 int PROT_READ ;
 int PROT_WRITE ;
 int R_OK ;
 int SEEK_END ;
 int SET4 (char* const,char,float,char,char) ;
 unsigned int UPX2 ;
 int X_OK ;
 scalar_t__ access (char*,int) ;
 int close (int const) ;
 int execve (char*,char**,char**) ;
 int exit (int) ;
 int fcntl (int const,int ,int ) ;
 int const getpid () ;
 unsigned int lseek (int const,int ,int ) ;
 char* mmap (char*,unsigned int const,int,int ,int const,int ) ;
 int open (char const*,int,int) ;
 int unlink (char const*) ;
 char* upx_itoa (int const,char* const) ;
 scalar_t__ write (int const,char* const,unsigned int const) ;

__attribute__((used)) static int



go_self(char const *tmpname, char *argv[], char *envp[])
{



    int const fdi = open(tmpname, O_RDONLY, 0);

    if (0 <= fdi) {



        char procself_buf[31+1];


        SET4(procself_buf + 0, '/', 'p', 'r', 'o');
        SET4(procself_buf + 4, 'c', '/', 0 , 0 );
        {
            char *const procself = upx_itoa(getpid(), procself_buf + 6);
            SET4(procself, '/', 'f', 'd', '/');
            upx_itoa(fdi, procself + 4);
        }



        if (UPX2 == (unsigned) access(procself_buf, R_OK | X_OK)) {

            unlink(tmpname);

            fcntl(fdi, F_SETFD, FD_CLOEXEC);

            execve(procself_buf, argv, envp);
            unsigned const lenf = lseek(fdi, 0, SEEK_END);
            char *const buf = mmap((char *)0, lenf, PROT_READ|PROT_WRITE,
                MAP_PRIVATE, fdi, 0);
            int const fdo = open(tmpname, O_WRONLY | O_CREAT | O_EXCL, 0700);
            if (lenf!=(unsigned)write(fdo, buf, lenf)) {
                exit(127);
            }
            close(fdo);
        }


        close(fdi);
    }
    return fdi;
}
