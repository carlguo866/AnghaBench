
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_3__ TYPE_1__ ;


struct cp {int id; char* enc; char* name; int * desc; } ;
struct TYPE_3__ {int CodePage; int MaxCharSize; char* CodePageName; } ;
typedef int DWORD ;
typedef TYPE_1__ CPINFOEX ;


 scalar_t__ GetCPInfoEx (int,int ,TYPE_1__*) ;
 int IsValidCodePage (int) ;
 int MB_ERR_INVALID_CHARS ;
 int WC_ERR_INVALID_CHARS ;
 struct cp* cp_map ;
 int printf (char*,...) ;

int
main(int argc, char **argv)
{
 DWORD cp;
 CPINFOEX info;
 struct cp *cur;
 int rnd = 0;
 printf("/* Autogenerated file. Update cp_enc_map_gen.c and regen like \n"
 " cp_enc_map_gen.exe > cp_enc_map.c \n*/\n\n");
 printf("static const struct php_win32_cp php_win32_cp_map[] = {");

 cur = &cp_map[0];




 while (cur->desc != ((void*)0)) {
  if (!IsValidCodePage(cur->id)) {



   printf("\t/* %u is invalid */\n", cur->id);

  } else if (GetCPInfoEx(cur->id, 0, &info)) {
   DWORD to_w_fl = 0, from_w_fl = 0;

   if (65001U == cur->id || 54936U == cur->id) {
    from_w_fl = WC_ERR_INVALID_CHARS;
    to_w_fl = MB_ERR_INVALID_CHARS;
   }


   if (!cur->enc[0]) {




    printf("\t{ %u, %u, %u, %u, \"%s\", NULL, \"%s\" },\n", info.CodePage, to_w_fl, from_w_fl, info.MaxCharSize, cur->name, info.CodePageName);
   } else {



    printf("\t{ %u, %u, %u, %u, \"%s\", \"%s\", \"%s\" },\n", info.CodePage, to_w_fl, from_w_fl, info.MaxCharSize, cur->name, cur->enc, info.CodePageName);
   }
  }
  cur++;
 }

 printf("};\n\n");

 return 0;
}
