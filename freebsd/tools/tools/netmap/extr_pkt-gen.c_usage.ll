; ModuleID = '/home/carl/AnghaBench/freebsd/tools/tools/netmap/extr_pkt-gen.c_usage.c'
source_filename = "/home/carl/AnghaBench/freebsd/tools/tools/netmap/extr_pkt-gen.c_usage.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

@.str = private unnamed_addr constant [8 x i8] c"pkt-gen\00", align 1
@stderr = common dso_local global i32 0, align 4
@.str.1 = private unnamed_addr constant [6137 x i8] c"Usage:\0A%s arguments\0A     -h      Show program usage and exit.\0A\0A     -i interface\0A             Name of the network interface that pkt-gen operates on.  It can be a system network interface\0A             (e.g., em0), the name of a vale(4) port (e.g., valeSSS:PPP), the name of a netmap pipe or\0A             monitor, or any valid netmap port name accepted by the nm_open library function, as docu-\0A             mented in netmap(4) (NIOCREGIF section).\0A\0A     -f function\0A             The function to be executed by pkt-gen.  Specify tx for transmission, rx for reception, ping\0A             for client-side ping-pong operation, and pong for server-side ping-pong operation.\0A\0A     -n count\0A             Number of iterations of the pkt-gen function, with 0 meaning infinite).  In case of tx or rx,\0A             count is the number of packets to receive or transmit.  In case of ping or pong, count is the\0A             number of ping-pong transactions.\0A\0A     -l pkt_size\0A             Packet size in bytes excluding CRC.  If passed a second time, use random sizes larger or\0A             equal than the second one and lower than the first one.\0A\0A     -b burst_size\0A             Transmit or receive up to burst_size packets at a time.\0A\0A     -4      Use IPv4 addresses.\0A\0A     -6      Use IPv6 addresses.\0A\0A     -d dst_ip[:port[-dst_ip:port]]\0A             Destination IPv4/IPv6 address and port, single or range.\0A\0A     -s src_ip[:port[-src_ip:port]]\0A             Source IPv4/IPv6 address and port, single or range.\0A\0A     -D dst_mac\0A             Destination MAC address in colon notation (e.g., aa:bb:cc:dd:ee:00).\0A\0A     -S src_mac\0A             Source MAC address in colon notation.\0A\0A     -a cpu_id\0A             Pin the first thread of pkt-gen to a particular CPU using pthread_setaffinity_np(3).  If more\0A             threads are used, they are pinned to the subsequent CPUs, one per thread.\0A\0A     -c cpus\0A             Maximum number of CPUs to use (0 means to use all the available ones).\0A\0A     -p threads\0A             Number of threads to use.  By default, only a single thread is used to handle all the netmap\0A             rings.  If threads is larger than one, each thread handles a single TX ring (in tx mode), a\0A             single RX ring (in rx mode), or a TX/RX ring couple.  The number of threads must be less or\0A             equal than the number of TX (or RX) ring available in the device specified by interface.\0A\0A     -T report_ms\0A             Number of milliseconds between reports.\0A\0A     -w wait_for_link_time\0A             Number of seconds to wait before starting the pkt-gen function, useuful to make sure that the\0A             network link is up.  A network device driver may take some time to enter netmap mode, or to\0A             create a new transmit/receive ring pair when netmap(4) requests one.\0A\0A     -R rate\0A             Packet transmission rate.  Not setting the packet transmission rate tells pkt-gen to transmit\0A             packets as quickly as possible.  On servers from 2010 on-wards netmap(4) is able to com-\0A             pletely use all of the bandwidth of a 10 or 40Gbps link, so this option should be used unless\0A             your intention is to saturate the link.\0A\0A     -X      Dump payload of each packet transmitted or received.\0A\0A     -H len  Add empty virtio-net-header with size 'len'.  Valid sizes are 0, 10 and 12.  This option is\0A             only used with Virtual Machine technologies that use virtio as a network interface.\0A\0A     -P file\0A             Load the packet to be transmitted from a pcap file rather than constructing it within\0A             pkt-gen.\0A\0A     -z      Use random IPv4/IPv6 src address/port.\0A\0A     -Z      Use random IPv4/IPv6 dst address/port.\0A\0A     -N      Do not normalize units (i.e., use bps, pps instead of Mbps, Kpps, etc.).\0A\0A     -F num_frags\0A             Send multi-slot packets, each one with num_frags fragments.  A multi-slot packet is repre-\0A             sented by two or more consecutive netmap slots with the NS_MOREFRAG flag set (except for the\0A             last slot).  This is useful to transmit or receive packets larger than the netmap buffer\0A             size.\0A\0A     -M frag_size\0A             In multi-slot mode, frag_size specifies the size of each fragment, if smaller than the packet\0A             length divided by num_frags.\0A\0A     -I      Use indirect buffers.  It is only valid for transmitting on VALE ports, and it is implemented\0A             by setting the NS_INDIRECT flag in the netmap slots.\0A\0A     -W      Exit immediately if all the RX rings are empty the first time they are examined.\0A\0A     -v      Increase the verbosity level.\0A\0A     -r      In tx mode, do not initialize packets, but send whatever the content of the uninitialized\0A             netmap buffers is (rubbish mode).\0A\0A     -A      Compute mean and standard deviation (over a sliding window) for the transmit or receive rate.\0A\0A     -B      Take Ethernet framing and CRC into account when computing the average bps.  This adds 4 bytes\0A             of CRC and 20 bytes of framing to each packet.\0A\0A     -C tx_slots[,rx_slots[,tx_rings[,rx_rings]]]\0A             Configuration in terms of number of rings and slots to be used when opening the netmap port.\0A             Such configuration has effect on software ports created on the fly, such as VALE ports and\0A             netmap pipes.  The configuration may consist of 1 to 4 numbers separated by commas: tx_slots,\0A             rx_slots, tx_rings, rx_rings.  Missing numbers or zeroes stand for default values.  As an\0A             additional convenience, if exactly one number is specified, then this is assigned to both\0A             tx_slots and rx_slots.  If there is no fourth number, then the third one is assigned to both\0A             tx_rings and rx_rings.\0A\0A     -o options\09\09data generation options (parsed using atoi)\0A\09\09\09\09OPT_PREFETCH\091\0A\09\09\09\09OPT_ACCESS\092\0A\09\09\09\09OPT_COPY\094\0A\09\09\09\09OPT_MEMCPY\098\0A\09\09\09\09OPT_TS\09\0916 (add a timestamp)\0A\09\09\09\09OPT_INDIRECT\0932 (use indirect buffers)\0A\09\09\09\09OPT_DUMP\0964 (dump rx/tx traffic)\0A\09\09\09\09OPT_RUBBISH\09256\0A\09\09\09\09\09(send wathever the buffers contain)\0A\09\09\09\09OPT_RANDOM_SRC  512\0A\09\09\09\09OPT_RANDOM_DST  1024\0A\09\09\09\09OPT_PPS_STATS   2048\0A\00", align 1
@llvm.used = appending global [1 x i8*] [i8* bitcast (void (i32)* @usage to i8*)], section "llvm.metadata"

; Function Attrs: noinline nounwind optnone uwtable
define internal void @usage(i32 %0) #0 {
  %2 = alloca i32, align 4
  %3 = alloca i8*, align 8
  store i32 %0, i32* %2, align 4
  store i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str, i64 0, i64 0), i8** %3, align 8
  %4 = load i32, i32* @stderr, align 4
  %5 = load i8*, i8** %3, align 8
  %6 = call i32 @fprintf(i32 %4, i8* getelementptr inbounds ([6137 x i8], [6137 x i8]* @.str.1, i64 0, i64 0), i8* %5)
  %7 = load i32, i32* %2, align 4
  %8 = call i32 @exit(i32 %7) #3
  unreachable
}

declare dso_local i32 @fprintf(i32, i8*, i8*) #1

; Function Attrs: noreturn
declare dso_local i32 @exit(i32) #2

attributes #0 = { noinline nounwind optnone uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="all" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="all" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="all" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { noreturn }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 10.0.1 (https://github.com/wsmoses/llvm-project-tok c8e5003577614e72d6d18a216e6a09771e1fcce4)"}
