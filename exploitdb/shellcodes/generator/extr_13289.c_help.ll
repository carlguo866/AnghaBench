; ModuleID = '/home/carl/AnghaBench/exploitdb/shellcodes/generator/extr_13289.c_help.c'
source_filename = "/home/carl/AnghaBench/exploitdb/shellcodes/generator/extr_13289.c_help.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

@.str = private unnamed_addr constant [2798 x i8] c"Beta was developed to convert raw binary shellcode into text that can be\0Aused in exploit source-code. It can convert raw binary data to a large\0Anumber of encodings.\0A\0A  Usage: BETA [options] [input file name]\0A\0A  input file name           Read input from the given file. By default BETA\0A                            reads input from stdin.\0A\0AGeneral options:\0A  --help                    Display this help and exit\0A  --version                 Output version information and exit\0A  --verbose                 Displays additional information.\0A  --pause                   Wait for keypress before exiting.\0A\0AEncoding options: (default = AA BB CC ...)\0A  \\x                        \\xAA\\xBB\\xCC ...\0A  0x                        0xAA 0xBB 0xCC ...\0A  %%                         %%AA%%BB%%CC...\0A  #                         &#111;&#222;&#33;...\0A  %%u                        %%uBBAA%%uDDCC...\0A  --noencode                Don't encode (only do checks).\0A\0ALayout options: (default = none)\0A  --chars/line=X            Output a new line after every X encoded bytes.\0A  --quotes                  Wrap output in quotes. Only usefull in combination\0A                            with chars/line argument.\0A  --quotesplus              Wrap output in quotes and add a '+' at the end\0A                            of each line. Only usefull in combination with\0A                            chars/line argument.\0A  --spaces                  Seperate encoding entities by spaces.\0A  --commas                  Seperate encoding entities by commas and spaces.\0A\0AAdditional options:\0A  --padbyte=AA              When using a multibyte encoding (e.g. %%uXXXX)\0A                            the data might need some padding. The given byte\0A                            will be used, the default value is %02x.\0A  --badbytes[=AA[,BB[...]]] Check the input for presence of the given char-\0A                            acters and report where they are found. You can\0A                            supply a comma seperated list of hexadecimal\0A                            character codes and the keywords \22alpha\22 and\0A                            \22print\22 (to check for the presence of nonalpha-\0A                            numeric or non-printable characters). If no char-\0A                            acters are supplied, the input will be checked for\0A                            the presence of 00, 0A and 0D. \0A  --marker[=AA[,BB[...]]]   The input contains both garbage and data. The data\0A                            is wrapped by the marker bytes, everything before\0A                            the first set and after the last set of marker\0A                            bytes will be ignored. If no marker bytes are\0A                            supplied, \22CC CC CC\22 (3xInt3) will be used.\0A                            You can supply up to %d bytes as marker.\0A\00", align 1
@DEFAULT_PAD_BYTE = common dso_local global i32 0, align 4
@MAX_MARKER_SIZE = common dso_local global i32 0, align 4

; Function Attrs: noinline nounwind optnone uwtable
define dso_local void @help() #0 {
  %1 = load i32, i32* @DEFAULT_PAD_BYTE, align 4
  %2 = load i32, i32* @MAX_MARKER_SIZE, align 4
  %3 = call i32 @printf(i8* getelementptr inbounds ([2798 x i8], [2798 x i8]* @.str, i64 0, i64 0), i32 %1, i32 %2)
  ret void
}

declare dso_local i32 @printf(i8*, i32, i32) #1

attributes #0 = { noinline nounwind optnone uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="all" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="all" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 10.0.1 (https://github.com/wsmoses/llvm-project-tok c8e5003577614e72d6d18a216e6a09771e1fcce4)"}
