
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_9__ TYPE_1__ ;


typedef int uint8 ;
typedef scalar_t__ uint32 ;
typedef int uint16 ;
struct TYPE_9__ {int * p; int * end; } ;
typedef TYPE_1__* STREAM ;
typedef int BOOL ;


 int False ;
 scalar_t__ SEC_RANDOM_SIZE ;


 int error (char*,scalar_t__) ;
 int in_uint16_le (TYPE_1__*,int) ;
 int in_uint32_le (TYPE_1__*,scalar_t__) ;
 int in_uint8p (TYPE_1__*,int *,scalar_t__) ;
 int in_uint8s (TYPE_1__*,int) ;
 int s_check_end (TYPE_1__*) ;
 int sec_parse_public_key (TYPE_1__*,int **,int **) ;

__attribute__((used)) static BOOL
sec_parse_crypt_info(STREAM s, uint32 * rc4_key_size,
       uint8 ** server_random, uint8 ** modulus, uint8 ** exponent)
{
 uint32 crypt_level, random_len, rsa_info_len;
 uint16 tag, length;
 uint8 *next_tag, *end;

 in_uint32_le(s, *rc4_key_size);
 in_uint32_le(s, crypt_level);
 if (crypt_level == 0)
  return False;
 in_uint32_le(s, random_len);
 in_uint32_le(s, rsa_info_len);

 if (random_len != SEC_RANDOM_SIZE)
 {
  error("random len %d\n", random_len);
  return False;
 }

 in_uint8p(s, *server_random, random_len);


 end = s->p + rsa_info_len;
 if (end > s->end)
  return False;

 in_uint8s(s, 12);

 while (s->p < end)
 {
  in_uint16_le(s, tag);
  in_uint16_le(s, length);

  next_tag = s->p + length;

  switch (tag)
  {
   case 128:
    if (!sec_parse_public_key(s, modulus, exponent))
     return False;

    break;

   case 129:


    break;
  }

  s->p = next_tag;
 }

 return s_check_end(s);
}
