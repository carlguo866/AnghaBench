
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;






struct sigaction {int size; int sample_period; int read_format; int disabled; int pinned; int exclude_kernel; int exclude_hv; int wakeup_events; int sample_type; int config; int type; int sa_flags; int sa_sigaction; } ;
struct perf_event_attr {int size; int sample_period; int read_format; int disabled; int pinned; int exclude_kernel; int exclude_hv; int wakeup_events; int sample_type; int config; int type; int sa_flags; int sa_sigaction; } ;


 int F_SETFL ;
 int F_SETOWN ;
 int F_SETSIG ;
 int MAP_SHARED ;
 int O_ASYNC ;
 int O_NONBLOCK ;
 int O_RDWR ;
 int PERF_COUNT_SW_CPU_CLOCK ;
 int PERF_EVENT_IOC_DISABLE ;
 int PERF_EVENT_IOC_ENABLE ;
 int PERF_EVENT_IOC_RESET ;
 int PERF_FORMAT_GROUP ;
 int PERF_FORMAT_ID ;
 int PERF_SAMPLE_IP ;
 int PERF_TYPE_SOFTWARE ;
 int PROT_READ ;
 int PROT_WRITE ;
 int SA_SIGINFO ;
 int SIGIO ;
 int close (int) ;
 int exit (int) ;
 int fcntl (int,int ,int) ;
 int fprintf (int ,char*) ;
 int getpid () ;
 int ioctl (int,int ,int ) ;
 int memset (struct sigaction*,int ,int) ;
 void* mmap (int *,int,int,int ,int,int ) ;
 int munmap (void*,int) ;
 int naive_matrix_multiply (int ) ;
 int our_handler ;
 int perf_event_open (struct sigaction*,int ,int,int,int ) ;
 int printf (char*,...) ;
 scalar_t__ sigaction (int,struct sigaction*,int *) ;
 int stderr ;
 int total ;

int main( int argc, char **argv ) {
 int fd;
 void *blargh;
 struct perf_event_attr pe;
 struct sigaction sa;
 memset(&sa, 0, sizeof(struct sigaction));
 sa.sa_sigaction=our_handler;
 sa.sa_flags=SA_SIGINFO;
 if (sigaction(SIGIO,&sa,((void*)0))<0) {
   fprintf(stderr,"Error setting up signal handler\n");
   exit(1);
 }
        memset(&pe,0,sizeof(struct perf_event_attr));
 pe.type=PERF_TYPE_SOFTWARE;
 pe.size=sizeof(struct perf_event_attr);
        pe.config=PERF_COUNT_SW_CPU_CLOCK;
 pe.sample_period=100000;
 pe.sample_type=PERF_SAMPLE_IP;
 pe.read_format=PERF_FORMAT_GROUP|PERF_FORMAT_ID;
 pe.disabled=1;
 pe.pinned=1;
 pe.exclude_kernel=1;
 pe.exclude_hv=1;
 pe.wakeup_events=1;
 fd=perf_event_open(&pe,0,-1,-1,0);
 if (fd<0) {
    printf("Error opening\n");
 }
 blargh=mmap(((void*)0),(1+2)*4096,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);
 fcntl(fd,F_SETFL,O_RDWR|O_NONBLOCK|O_ASYNC);
 fcntl(fd,F_SETSIG,SIGIO);
 fcntl(fd,F_SETOWN,getpid());
 ioctl(fd,PERF_EVENT_IOC_RESET,0);
 ioctl(fd,PERF_EVENT_IOC_ENABLE,0);
 naive_matrix_multiply(0);
 ioctl(fd,PERF_EVENT_IOC_DISABLE,0);
 munmap(blargh,(1+2)*4096);
 close(fd);
 printf("Total overflows: %d\n",total);
 return 0;
}
