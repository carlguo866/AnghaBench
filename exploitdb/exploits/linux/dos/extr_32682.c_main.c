
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;






typedef int pid_t ;
typedef int FILE ;


 int MAXTASKS ;
 unsigned int atoi (char*) ;
 int execl (char*,char*,char*,char*,int *) ;
 int fclose (int *) ;
 int * fopen (char*,char*) ;
 int fork () ;
 int printf (char*,...) ;
 int sprintf (char*,char*,char*) ;
 int * stderr ;
 int * stdout ;
 int waitpid (int,int *,int ) ;

int main(int argc, char *argv[])
{
 int i;
 char cmd[128];
 FILE *f;
 pid_t pids[MAXTASKS];
 pid_t pid;
 unsigned int num;

 if (argc < 3) {
  printf("enter netserver hostname as the first parameter\n");
  printf("enter number of netperf tasks as the second parameter\n");
  return 1;
 }

 f = fopen("/dev/null", "w");
 if (!f) {
  printf("cannot open /dev/nu;;\n");
  return 2;
 }
 sprintf(cmd, "netperf -H %s -l 60 -t UDP_STREAM -- -s 262144 -r 262144 -m 16384", argv[1]);

 num = atoi(argv[2]);
 if (num > MAXTASKS) {
  printf("number of tasks is too high, resetting to %ld\n", MAXTASKS);
  num = MAXTASKS;
 }

 for(i = 0; i < num; i++) {
  pid = fork();
  if (pid == 0) {
   fclose(stdout);
   fclose(stderr);
   stdout = f;
   stderr = f;
   execl("/bin/sh", "/bin/sh", "-c", cmd, ((void*)0));
  }
  else {
   printf("newpid: %d\n", pid);
   pids[i] = pid;
  }
 }
 for(i = 0; i < num; i++) {
  waitpid(pids[i], ((void*)0), 0);
 }

 fclose(f);

 return 0;
}
