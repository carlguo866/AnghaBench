
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;






struct pollfd {int fd; int events; int revents; } ;
typedef int nfds_t ;


 scalar_t__ EINTR ;
 int EXIT_FAILURE ;
 int EXIT_SUCCESS ;
 int IN_ACCESS ;
 int IN_CLOSE ;
 int IN_NONBLOCK ;
 int IN_OPEN ;
 int POLLIN ;
 int STDIN_FILENO ;
 int* calloc (int,int) ;
 int close (int) ;
 scalar_t__ errno ;
 int exit (int ) ;
 int fprintf (int ,char*,char*) ;
 int free (int*) ;
 int handle_events (int,int*,int,char**) ;
 int inotify_add_watch (int,char*,int) ;
 int inotify_init1 (int ) ;
 int perror (char*) ;
 int poll (struct pollfd*,int,int) ;
 int printf (char*) ;
 int stderr ;
 int stop ;

__attribute__((used)) static void* notify_thread_func(void* arg)
{
   char buf;
   int fd, i, poll_num;
   int *wd;
   nfds_t nfds;
   struct pollfd fds[2];

   int argc = 2;
   char *argv[] = { ((void*)0), "test_dir", ((void*)0)};
   fd = inotify_init1(IN_NONBLOCK);
   if (fd == -1) {
       perror("inotify_init1");
       exit(EXIT_FAILURE);
   }



   wd = calloc(argc, sizeof(int));
   if (wd == ((void*)0)) {
       perror("calloc");
       exit(EXIT_FAILURE);
   }





   for (i = 1; i < argc; i++) {
       wd[i] = inotify_add_watch(fd, argv[i],
                                 IN_OPEN | IN_CLOSE| IN_ACCESS);
       if (wd[i] == -1) {
           fprintf(stderr, "Cannot watch '%s'\n", argv[i]);
           perror("inotify_add_watch");
           exit(EXIT_FAILURE);
       }
   }



   nfds = 2;



   fds[0].fd = STDIN_FILENO;
   fds[0].events = POLLIN;



   fds[1].fd = fd;
   fds[1].events = POLLIN;

   printf("Listening for events.\n");
   while (!stop) {
       poll_num = poll(fds, nfds, -1);
       if (poll_num == -1) {
           if (errno == EINTR)
               continue;
           perror("poll");
           exit(EXIT_FAILURE);
       }

       if (poll_num > 0) {

           if (fds[1].revents & POLLIN) {

               handle_events(fd, wd, argc, argv);
           }
       }
   }

   close(fd);

   free(wd);
   exit(EXIT_SUCCESS);
}
