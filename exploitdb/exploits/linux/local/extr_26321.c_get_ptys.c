
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;






typedef int tag ;
typedef int result ;
typedef int op ;
typedef int GnomePtyOps ;


 int FD_CLOEXEC ;
 int F_SETFD ;
 int GNOME_PTY_OPEN_NO_DB_UPDATE ;
 int GNOME_PTY_OPEN_PTY_LASTLOG ;
 int GNOME_PTY_OPEN_PTY_LASTLOGUTMP ;
 int GNOME_PTY_OPEN_PTY_LASTLOGUWTMP ;
 int GNOME_PTY_OPEN_PTY_LASTLOGWTMP ;
 int GNOME_PTY_OPEN_PTY_UTMP ;
 int GNOME_PTY_OPEN_PTY_UWTMP ;
 int GNOME_PTY_OPEN_PTY_WTMP ;
 int ZVT_TERM_DO_LASTLOG ;
 int ZVT_TERM_DO_UTMP_LOG ;
 int ZVT_TERM_DO_WTMP_LOG ;
 int close (int) ;
 int dup2 (int,int) ;
 int execl (char*,char*,int *) ;
 int exit (int) ;
 int fcntl (int,int ,int ) ;
 int fork () ;
 int helper_pid ;
 int* helper_socket_fdpassing ;
 int* helper_socket_protocol ;
 int read (int,...) ;
 int receive_fd (int) ;
 int s_pipe (int*) ;
 scalar_t__ write (int,int *,int) ;

__attribute__((used)) static void *
get_ptys (int *master, int *slave, int update_wutmp)
{
 GnomePtyOps op;
 int result, n;
 void *tag;

 if (helper_pid == -1)
  return ((void*)0);

 if (helper_pid == 0){
  if (s_pipe (helper_socket_protocol) == -1)
   return ((void*)0);

  if (s_pipe (helper_socket_fdpassing) == -1){
   close (helper_socket_protocol [0]);
   close (helper_socket_protocol [1]);
   return ((void*)0);
  }

  helper_pid = fork ();

  if (helper_pid == -1){
   close (helper_socket_protocol [0]);
   close (helper_socket_protocol [1]);
   close (helper_socket_fdpassing [0]);
   close (helper_socket_fdpassing [1]);
   return ((void*)0);
  }

  if (helper_pid == 0){
   close (0);
   close (1);
   dup2 (helper_socket_protocol [1], 0);
   dup2 (helper_socket_fdpassing [1], 1);


   close (helper_socket_protocol [0]);
   close (helper_socket_protocol [1]);
   close (helper_socket_fdpassing [0]);
   close (helper_socket_fdpassing [1]);

   execl ("/usr/sbin/gnome-pty-helper", "gnome-pty-helper", ((void*)0));
   exit (1);
  } else {
   close (helper_socket_fdpassing [1]);
   close (helper_socket_protocol [1]);







   fcntl (helper_socket_protocol [0], F_SETFD, FD_CLOEXEC);
   fcntl (helper_socket_fdpassing [0], F_SETFD, FD_CLOEXEC);
  }
 }
 op = GNOME_PTY_OPEN_NO_DB_UPDATE;

 if (update_wutmp & ZVT_TERM_DO_UTMP_LOG){
  if (update_wutmp & (ZVT_TERM_DO_WTMP_LOG | ZVT_TERM_DO_LASTLOG))
   op = GNOME_PTY_OPEN_PTY_LASTLOGUWTMP;
  else if (update_wutmp & ZVT_TERM_DO_WTMP_LOG)
   op = GNOME_PTY_OPEN_PTY_UWTMP;
  else if (update_wutmp & ZVT_TERM_DO_LASTLOG)
   op = GNOME_PTY_OPEN_PTY_LASTLOGUTMP;
  else
   op = GNOME_PTY_OPEN_PTY_UTMP;
 } else if (update_wutmp & ZVT_TERM_DO_WTMP_LOG) {
  if (update_wutmp & (ZVT_TERM_DO_WTMP_LOG | ZVT_TERM_DO_LASTLOG))
   op = GNOME_PTY_OPEN_PTY_LASTLOGWTMP;
  else if (update_wutmp & ZVT_TERM_DO_WTMP_LOG)
   op = GNOME_PTY_OPEN_PTY_WTMP;
 } else
  if (update_wutmp & ZVT_TERM_DO_LASTLOG)
   op = GNOME_PTY_OPEN_PTY_LASTLOG;

 if (write (helper_socket_protocol [0], &op, sizeof (op)) < 0)
  return ((void*)0);

 n = read (helper_socket_protocol [0], &result, sizeof (result));
 if (n == -1 || n != sizeof (result)){
  helper_pid = 0;
  return ((void*)0);
 }

 if (result == 0)
  return ((void*)0);

 n = read (helper_socket_protocol [0], &tag, sizeof (tag));

 if (n == -1 || n != sizeof (tag)){
  helper_pid = 0;
  return ((void*)0);
 }

 *master = receive_fd (helper_socket_fdpassing [0]);
 *slave = receive_fd (helper_socket_fdpassing [0]);

 return tag;
}
