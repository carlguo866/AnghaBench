
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;






struct timeval {int tv_sec; scalar_t__ tv_usec; } ;
struct sctp_hdr {int dport; int sport; scalar_t__ chunks; } ;
struct sctp_chk {scalar_t__ type; scalar_t__ data; } ;
struct iphdr {int dummy; } ;
typedef int packet ;
typedef int fd_set ;
typedef int __u32 ;
typedef scalar_t__ __u16 ;


 int FD_SET (int,int *) ;
 int FD_ZERO (int *) ;
 int IPPROTO_SCTP ;
 int PF_INET ;
 scalar_t__ SCTP_INIT_ACK ;
 scalar_t__ SCTP_SACK ;
 int SOCK_RAW ;
 int __fatal_perror (char*) ;
 int ntohl (int ) ;
 scalar_t__ ntohs (int ) ;
 int read (int,char*,int) ;
 scalar_t__ select (int,int *,int *,int *,struct timeval*) ;
 int socket (int ,int ,int ) ;

int raw_socket_engine(__u16 sp, __u16 sp2, __u16 dp,
                      __u32 *tsn, __u32 *vtag, __u32 *tsn2, __u32 *vtag2)
{
  char packet[1500];
  int p_len;
  void *end;
  struct sctp_hdr *hdr;
  struct sctp_chk *chk;
  __u32 tmp;
  __u16 psp,pdp;
  fd_set r;
  struct timeval tv;

  int raw_fd = socket(PF_INET, SOCK_RAW, IPPROTO_SCTP);
  if(raw_fd < 0)
    __fatal_perror("socket: RAW/SCTP");


  FD_ZERO(&r);
  FD_SET(raw_fd, &r);
  tv.tv_usec=0;
  tv.tv_sec=10;

  while(select(raw_fd + 1, &r, ((void*)0),((void*)0),&tv) > 0)
  {
    p_len = read(raw_fd, packet, sizeof(packet));
    end = packet + p_len;
    hdr = (struct sctp_hdr *)(packet + sizeof(struct iphdr));
    if((void*)(((char *)hdr)+4) >= end)
      continue;


    chk = (struct sctp_chk *)(hdr->chunks);
    tmp = ntohl(*((__u32*)(chk->data)));
    psp = ntohs(hdr->sport);
    pdp = ntohs(hdr->dport);

    if(chk->type == SCTP_SACK)
    {
      if(psp == dp && pdp == sp)
        *tsn = tmp;

      if(psp == dp && pdp == sp2)
        *tsn2 = tmp;
    }

    if(chk->type == SCTP_INIT_ACK)
    {
      if(psp == dp && pdp == sp)
        *vtag = tmp;

      if(psp == dp && pdp == sp2)
        *vtag2 = tmp;
    }

    if(*vtag && *tsn && *vtag2 && *tsn2)
      break;

    FD_ZERO(&r);
    FD_SET(raw_fd, &r);
    tv.tv_usec=0;
    tv.tv_sec=10;
  }

  return 0;
}
