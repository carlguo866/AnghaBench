
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_4__ TYPE_1__ ;


typedef int uint16_t ;
struct TYPE_4__ {int conn_id_length; int conn_id; int * x509; } ;
typedef TYPE_1__ ssl_conn ;
typedef int buf ;


 int BUFSIZE ;
 int SSL2_MAX_CONNECTION_ID_LENGTH ;
 int SSL2_MT_SERVER_HELLO ;
 int * d2i_X509 (int *,unsigned char**,long) ;
 int exit (int) ;
 int memcpy (int ,unsigned char*,int) ;
 int n2s (unsigned char*,int) ;
 int ntohs (int ) ;
 int printf (char*,...) ;
 int read_ssl_packet (TYPE_1__*,unsigned char*,int) ;
 char* ssl_error (int ) ;

void get_server_hello(ssl_conn* ssl)
{
 unsigned char buf[BUFSIZE];
 unsigned char *p, *end;
 int len;
 int server_version, cert_length, cs_length, conn_id_length;
 int found;

 if (!(len = read_ssl_packet(ssl, buf, sizeof(buf)))) {
  printf("Server error: %s\n", ssl_error(ntohs(*(uint16_t*)&buf[1])));
  exit(1);
 }
 if (len < 11) {
  printf("get_server_hello: Packet too short (len = %d)\n", len);
  exit(1);
 }

 p = buf;

 if (*(p++) != SSL2_MT_SERVER_HELLO) {
  printf("get_server_hello: Expected SSL2 MT SERVER HELLO, got %x\n", (int)p[-1]);
  exit(1);
 }

 if (*(p++) != 0) {
  printf("get_server_hello: SESSION-ID-HIT is not 0\n");
  exit(1);
 }

 if (*(p++) != 1) {
  printf("get_server_hello: CERTIFICATE-TYPE is not SSL CT X509 CERTIFICATE\n");
  exit(1);
 }

 n2s(p, server_version);
 if (server_version != 2) {
  printf("get_server_hello: Unsupported server version %d\n", server_version);
  exit(1);
 }

 n2s(p, cert_length);
 n2s(p, cs_length);
 n2s(p, conn_id_length);

 if (len != 11 + cert_length + cs_length + conn_id_length) {
  printf("get_server_hello: Malformed packet size\n");
  exit(1);
 }


 ssl->x509 = ((void*)0);
 ssl->x509=d2i_X509(((void*)0),&p,(long)cert_length);
 if (ssl->x509 == ((void*)0)) {
  printf("get server hello: Cannot parse x509 certificate\n");
  exit(1);
 }

 if (cs_length % 3 != 0) {
  printf("get server hello: CIPHER-SPECS-LENGTH is not a multiple of 3\n");
  exit(1);
 }

 found = 0;
 for (end=p+cs_length; p < end; p += 3) {
  if ((p[0] == 0x01) && (p[1] == 0x00) && (p[2] == 0x80))
   found = 1;
 }

 if (!found) {
  printf("get server hello: Remote server does not support 128 bit RC4\n");
  exit(1);
 }

 if (conn_id_length > SSL2_MAX_CONNECTION_ID_LENGTH) {
  printf("get server hello: CONNECTION-ID-LENGTH is too long\n");
  exit(1);
 }


 ssl->conn_id_length = conn_id_length;
 memcpy(ssl->conn_id, p, conn_id_length);
}
