
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_2__ TYPE_1__ ;


struct timeval {int tv_sec; scalar_t__ tv_usec; } ;
struct TYPE_2__ {int s_addr; } ;
struct sockaddr_in {TYPE_1__ sin_addr; void* sin_port; int sin_family; } ;
struct sockaddr {int dummy; } ;
typedef int sin ;
typedef int fd_set ;


 int AF_INET ;
 scalar_t__ EINPROGRESS ;
 int FD_SET (int,int *) ;
 int FD_SETSIZE ;
 int FD_ZERO (int *) ;
 int F_GETFL ;
 int F_SETFL ;
 int INADDR_ANY ;
 int IPPROTO_TCP ;
 int O_NONBLOCK ;
 int SOCK_STREAM ;
 int bind (int,struct sockaddr*,int) ;
 int connect (int,struct sockaddr*,int) ;
 scalar_t__ errno ;
 int exit (int) ;
 int fatalerr (char*,char*,int) ;
 scalar_t__ fcntl (int,int ,int) ;
 scalar_t__ getpeername (int,struct sockaddr*,int*) ;
 int htonl (int ) ;
 void* htons (int) ;
 int net_resolve (char*) ;
 int perror (char*) ;
 scalar_t__ select (int ,int *,int *,int *,struct timeval*) ;
 int socket (int ,int ,int ) ;
 char* strerror (scalar_t__) ;

int net_connect(char *host, int port, int timeout)
{
 int fd, i, flags, sock_len;
 struct sockaddr_in sin;
 struct timeval tv;
 fd_set fds;


 if ((fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
  perror("socket");
  exit(1);
 }


 sin.sin_family = AF_INET;
 sin.sin_addr.s_addr = htonl(INADDR_ANY);
 for (i = 1023; i > 0; i--) {
  sin.sin_port = htons(i);
  if (!(bind(fd, (struct sockaddr *)&sin, sizeof(sin))))
   break;
 }
 if (i == 0)
  fatalerr("error", "Can't bind a privileged port (must be root)", fd);


 sin.sin_port = htons(port);
 if (!(sin.sin_addr.s_addr = net_resolve(host)))
  fatalerr("error", "Can't resolve hostname", fd);


 if ((flags = fcntl(fd, F_GETFL, 0)) < 0)
  fatalerr("fcntl", strerror(errno), fd);
 if (fcntl(fd, F_SETFL, flags | O_NONBLOCK) < 0)
  fatalerr("fcntl", strerror(errno), fd);


 if (!(connect(fd, (struct sockaddr *)&sin, sizeof(sin)))) {
  if (fcntl(fd, F_SETFL, flags) < 0)
   fatalerr("fcntl", strerror(errno), fd);
  return(fd);
 }
 if (errno != EINPROGRESS)
  fatalerr("error", "Can't connect to remote host", fd);


 tv.tv_sec = timeout;
 tv.tv_usec = 0;


 FD_ZERO(&fds);
 FD_SET(fd, &fds);


 if (select(FD_SETSIZE, ((void*)0), &fds, ((void*)0), &tv) <= 0)
  fatalerr("error", "Can't connect to remote host", fd);


 sock_len = sizeof(sin);
 if (getpeername(fd, (struct sockaddr *)&sin, &sock_len) < 0)
  fatalerr("error", "Can't connect to remote host", fd);
 if (fcntl(fd, F_SETFL, flags) < 0)
  fatalerr("fcntl", strerror(errno), fd);
 return(fd);
}
