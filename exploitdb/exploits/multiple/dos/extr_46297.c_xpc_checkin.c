
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_9__ TYPE_4__ ;
typedef struct TYPE_8__ TYPE_3__ ;
typedef struct TYPE_7__ TYPE_2__ ;
typedef struct TYPE_6__ TYPE_1__ ;


struct TYPE_9__ {int msgh_size; char msgh_id; void* msgh_remote_port; int msgh_bits; } ;
struct TYPE_8__ {void* type; int disposition; void* name; } ;
struct TYPE_7__ {void* type; int disposition; void* name; } ;
struct TYPE_6__ {int msgh_descriptor_count; } ;
struct xpc_w00t {TYPE_4__ hdr; TYPE_3__ reply_port; TYPE_2__ client_port; TYPE_1__ body; } ;
typedef int msg ;
typedef void* mach_port_t ;
typedef scalar_t__ kern_return_t ;


 int EXIT_FAILURE ;
 scalar_t__ KERN_SUCCESS ;
 int MACH_MSGH_BITS_COMPLEX ;
 int MACH_MSGH_BITS_SET (int ,int ,int ,int ) ;
 int MACH_MSG_OPTION_NONE ;
 void* MACH_MSG_PORT_DESCRIPTOR ;
 int MACH_MSG_TIMEOUT_NONE ;
 int MACH_MSG_TYPE_COPY_SEND ;
 int MACH_MSG_TYPE_MAKE_SEND ;
 int MACH_MSG_TYPE_MOVE_RECEIVE ;
 int MACH_PORT_NULL ;
 int MACH_PORT_RIGHT_RECEIVE ;
 int MACH_SEND_MSG ;
 int exit (int ) ;
 char* mach_error_string (scalar_t__) ;
 scalar_t__ mach_msg (TYPE_4__*,int,int,int ,int ,int ,int ) ;
 scalar_t__ mach_port_allocate (int ,int ,void**) ;
 scalar_t__ mach_port_insert_right (int ,void*,void*,int ) ;
 int mach_task_self () ;
 int memset (TYPE_4__*,int ,int) ;
 int printf (char*,...) ;

__attribute__((used)) static int
xpc_checkin(
  mach_port_t service_port,
  mach_port_t* client_port,
  mach_port_t* reply_port)
{

  kern_return_t err;
  err = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, client_port);
  if (err != KERN_SUCCESS) {
    printf("port allocation failed: %s\n", mach_error_string(err));
    exit(EXIT_FAILURE);
  }


  err = mach_port_insert_right(mach_task_self(), *client_port, *client_port, MACH_MSG_TYPE_MAKE_SEND);
  if (err != KERN_SUCCESS) {
    printf("port right insertion failed: %s\n", mach_error_string(err));
    exit(EXIT_FAILURE);
  }

  err = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, reply_port);
  if (err != KERN_SUCCESS) {
    printf("port allocation failed: %s\n", mach_error_string(err));
    exit(EXIT_FAILURE);
  }

  struct xpc_w00t msg;
  memset(&msg.hdr, 0, sizeof(msg));
  msg.hdr.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, 0, 0, MACH_MSGH_BITS_COMPLEX);
  msg.hdr.msgh_size = sizeof(msg);
  msg.hdr.msgh_remote_port = service_port;
  msg.hdr.msgh_id = 'w00t';

  msg.body.msgh_descriptor_count = 2;

  msg.client_port.name = *client_port;
  msg.client_port.disposition = MACH_MSG_TYPE_MOVE_RECEIVE;
  msg.client_port.type = MACH_MSG_PORT_DESCRIPTOR;

  msg.reply_port.name = *reply_port;
  msg.reply_port.disposition = MACH_MSG_TYPE_MAKE_SEND;
  msg.reply_port.type = MACH_MSG_PORT_DESCRIPTOR;

  err = mach_msg(&msg.hdr,
                 MACH_SEND_MSG|MACH_MSG_OPTION_NONE,
                 msg.hdr.msgh_size,
                 0,
                 MACH_PORT_NULL,
                 MACH_MSG_TIMEOUT_NONE,
                 MACH_PORT_NULL);
  if (err != KERN_SUCCESS) {
    printf("w00t message send failed: %s\n", mach_error_string(err));
    exit(EXIT_FAILURE);
  } else {
    printf("sent xpc w00t message\n");
  }

  return 1;
}
