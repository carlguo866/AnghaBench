
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_2__ TYPE_1__ ;


typedef int u_long ;
struct timeval {int tv_sec; int tv_usec; } ;
struct TYPE_2__ {int s_addr; } ;
struct sockaddr_in {TYPE_1__ sin_addr; int sin_family; int sin_port; } ;
struct sockaddr {int dummy; } ;
typedef int sock_in ;
typedef int fd_set ;
typedef int WORD ;
typedef int SOCKET ;
typedef int DWORD ;


 int AF_INET ;
 int FD_ISSET (int,int *) ;
 int FIONBIO ;
 int INVALID_SOCKET ;
 int IPPROTO_TCP ;
 int SOCKET_ERROR ;
 int SOCK_STREAM ;
 int closesocket (int) ;
 int connect (int,struct sockaddr*,int) ;
 int ioctlsocket (int,int ,int *) ;
 int memset (struct sockaddr_in*,int ,int) ;
 int select (int ,int *,int *,int *,struct timeval*) ;
 int socket (int ,int ,int ) ;

SOCKET TCPConnect(DWORD dwIP,WORD wPort,DWORD dwTimeout)
{
 struct sockaddr_in sock_in;
 struct timeval timeout;
 DWORD fdWrite[2];
 DWORD fdExcept[2];
 SOCKET s;
 int slResult;
 int val=1,len=sizeof(int);

 s=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
 if (s==INVALID_SOCKET)
  return SOCKET_ERROR;

 ioctlsocket(s,FIONBIO,(u_long*)&val);

 fdWrite[0]=fdExcept[0]=1;
 fdWrite[1]=fdExcept[1]=s;

 memset(&sock_in,0,sizeof(sock_in));
 sock_in.sin_port=wPort;
 sock_in.sin_family=AF_INET;
 sock_in.sin_addr.s_addr=dwIP;

 connect(s,(struct sockaddr*)&sock_in,sizeof(sock_in));

 timeout.tv_sec=dwTimeout/1000;
 timeout.tv_usec=dwTimeout%1000;

 slResult=select(0,((void*)0),(fd_set*)&fdWrite,(fd_set*)&fdExcept,&timeout);
 switch(slResult)
 {
  case -1:
  case 0:
  {
   closesocket(s);
   return SOCKET_ERROR;
  }

  default:
  {
   if (!FD_ISSET(s,(fd_set*)&fdExcept))
   {
    val=0;ioctlsocket(s,FIONBIO,(u_long*)&val);
    return s;
   }
   break;
  }
 }

 closesocket(s);
 return SOCKET_ERROR;
}
