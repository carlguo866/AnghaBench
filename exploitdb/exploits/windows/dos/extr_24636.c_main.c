
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_3__ TYPE_1__ ;


struct TYPE_3__ {int type; int port; int buf; int pio; int display; int ipad; } ;
typedef TYPE_1__ rose_params ;
typedef scalar_t__ netwib_err ;
typedef int netwib_buf ;


 int NETWIB_ERR_ENCODETYPE_FULL ;
 scalar_t__ NETWIB_ERR_OK ;
 int NETWIB_FALSE ;
 int NETWIB_IP_DECODETYPE_BEST ;
 int NETWIB_SPOOF_IP_INITTYPE_LINKBRAW ;
 int NUM_DELTA ;
 int NUM_FRAG ;
 int NUM_LAST ;
 int NUM_RUN ;


 void* atoi (char*) ;
 int netwib_buf_close (int *) ;
 int netwib_buf_init_ext_text (char*,int *) ;
 int netwib_buf_init_mallocdefault (int *) ;
 int netwib_close () ;
 int netwib_er (int ) ;
 int netwib_err_display (scalar_t__,int ) ;
 int netwib_init () ;
 int netwib_io_close (int *) ;
 int netwib_io_init_spoof_ip (int ,int *) ;
 scalar_t__ netwib_ip_init_buf (int *,int ,int *) ;
 int printf (char*,...) ;
 scalar_t__ rose_loop (TYPE_1__*,int,int,int,int,int) ;

int main(int argc, char* argv[])
{
  rose_params rp;
  netwib_buf ipstr;
  netwib_err ret;
  int npack, nrew, nrun, nfrag, ndelta;


  netwib_init();


  if (argc < 3 || argc > 9) {
    printf("Usage  : %s type(1or2) ipaddress [port] [NumP] [Numt] [NumR] [NumF] [NumD]\n", argv[0]);
    printf("Example: %s 1 1.2.3.4 80 5 9999 99999999 1021 8\n", argv[0]);
    printf(" type      : %d=tcp, %d=udp\n", 129, 128);
    printf(" ipaddress : address to test\n");
    printf(" port      : optional port number (0 means random)\n");
    printf(" NumP      : Number of packets to fragment\n");
    printf(" NumT      : Number of times last fragment is rewritten\n");
    printf(" NumR      : Number of times to run test\n");
    printf(" NumF      : Number of fragments per packet\n");
    printf(" NumD      : Delta between fragements.\n");
   return(1);
  }


  rp.type = atoi(argv[1]);
  switch(rp.type) {
  case 129 :
  case 128 :
    break;
  default :
    printf("First parameter must be 1 or 2 (currently=%s)\n", argv[1]);
    return(2);
  }


  netwib_er(netwib_buf_init_ext_text(argv[2], &ipstr));
  ret = netwib_ip_init_buf(&ipstr, NETWIB_IP_DECODETYPE_BEST, &rp.ipad);
  if (ret != NETWIB_ERR_OK) {
    printf("Second parameter must be an IP or hostname (currently=%s)\n",
           argv[2]);
    return(3);
  }


  rp.port = 0;
  if (argc > 3) {
    rp.port = atoi(argv[3]);
  }


  npack = 5;
  if (argc > 4) {
    npack = atoi(argv[4]);
    }
  if (npack < 1) { npack = 1; }
  if (npack > 1000) { npack = 1000; }


  nrew = NUM_LAST;
  if (argc > 5) {
    nrew = atoi(argv[5]);
    }


  nrun = NUM_RUN;
  if (argc > 6) {
    nrun = atoi(argv[6]);
    }


  nfrag = NUM_FRAG;
  if (argc > 7) {
    nfrag = atoi(argv[7]);
    }
  if (nfrag < 1) { nfrag = 1; }


    ndelta = NUM_DELTA;
    if (argc > 8) {
      ndelta = atoi(argv[8]);
      }



    nfrag = (nfrag * ndelta) + 8;
    if (nfrag > 8170) { nfrag = 8170; }

  printf("%s %d %s %d %d %d %d %d ndelta = %d\n\r",
          argv[0], rp.type, argv[2], rp.port, npack, nrew, nrun,
   nfrag / 8, ndelta);


  rp.display = NETWIB_FALSE;


  netwib_er(netwib_buf_init_mallocdefault(&rp.buf));


  netwib_er(netwib_io_init_spoof_ip(NETWIB_SPOOF_IP_INITTYPE_LINKBRAW,
                                    &rp.pio));


  ret = rose_loop(&rp, npack, nrew, nrun, nfrag, ndelta);
  if (ret != NETWIB_ERR_OK) {
    netwib_er(netwib_err_display(ret, NETWIB_ERR_ENCODETYPE_FULL));
    return(ret);
  }


  netwib_er(netwib_io_close(&rp.pio));
  netwib_er(netwib_buf_close(&rp.buf));
  netwib_close();

  return(0);
}
