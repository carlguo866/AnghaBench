
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;






struct timeval {int tv_sec; unsigned long tv_usec; } ;
struct sockaddr_in {int sin_addr; int sin_port; int sin_family; } ;
struct sockaddr {int dummy; } ;
typedef int socklen_t ;
typedef int remote_addr ;
typedef int fd_set ;
typedef int error ;


 int AF_INET ;
 int EINPROGRESS ;
 int ETIMEDOUT ;
 scalar_t__ FD_ISSET (int,int *) ;
 int FD_SET (int,int *) ;
 int FD_ZERO (int *) ;
 int F_GETFL ;
 int F_SETFL ;
 int O_NONBLOCK ;
 int SOCK_STREAM ;
 int SOL_SOCKET ;
 int SO_ERROR ;
 int close (int) ;
 int connect (int,struct sockaddr*,int) ;
 int errno ;
 int exit (int) ;
 scalar_t__ fcntl (int,int ,int) ;
 scalar_t__ getsockopt (int,int ,int ,int*,int*) ;
 int htons (unsigned short) ;
 int inet_pton (int ,char*,int *) ;
 int memset (struct sockaddr_in*,int,int) ;
 int printf (char*) ;
 int select (int,int *,int *,int *,struct timeval*) ;
 int socket (int ,int ,int ) ;

int
is_open ( char* ip, unsigned short tport )
{
 int s, n, error;
 int flags;
 int sec = 0;
 unsigned long usec = 10000;
 struct sockaddr_in remote_addr;
 struct timeval tval;
 fd_set rset, wset;
 socklen_t len;

 memset ( &remote_addr, 0x0, sizeof ( remote_addr ) );
 remote_addr.sin_family = AF_INET;
 remote_addr.sin_port = htons ( tport );
 inet_pton ( AF_INET, ip, &remote_addr.sin_addr );
 if ( ( s = socket ( AF_INET, SOCK_STREAM, 0 ) ) < 0 )
 {
  printf ( "socket failed!\n" );
  exit ( -1 );
 }

 if ( ( flags = fcntl ( s, F_GETFL, 0 ) ) < 0 )
 {
  close ( s );
  return ( -1 );
 }
 if ( fcntl ( s, F_SETFL, flags | O_NONBLOCK ) < 0 )
 {
  close ( s );
  return ( -1 );
 }
 if ( ( n = connect ( s, ( struct sockaddr * ) &remote_addr, sizeof ( struct sockaddr ) ) ) == -1 )
 {
  if ( errno != EINPROGRESS )
  {
   close ( s );
   return ( -1 );
  }
 }
 if ( n == 0 )
  goto done;
 FD_ZERO ( &rset );
 FD_SET ( s, &rset );
 wset = rset;
 tval.tv_sec = sec;
 tval.tv_usec = usec;

 if ( ( n = select ( s + 1, &rset, &wset, ((void*)0), &tval ) ) == 0 )
 {
  close ( s );
  errno = ETIMEDOUT;
  return ( 1 );
 }
 if ( FD_ISSET ( s, &rset ) || FD_ISSET ( s, &wset ) )
 {
  len = sizeof ( error );
  if ( getsockopt ( s, SOL_SOCKET, SO_ERROR, &error, &len ) < 0 )
   return ( -1 );
 }
 else
 {
  printf ( "select failed!\n" );
  exit ( 1 );
 }
 done:
  if ( fcntl ( s, F_SETFL, flags ) < 0 )
  {
   close ( s );
   return ( -1 );
  }
  if ( error )
  {
   close ( s );
   errno = error;
   return ( -1 );
  }
 return ( 0 );
}
