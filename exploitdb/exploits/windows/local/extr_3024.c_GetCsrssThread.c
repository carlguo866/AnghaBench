
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_6__ TYPE_3__ ;
typedef struct TYPE_5__ TYPE_2__ ;
typedef struct TYPE_4__ TYPE_1__ ;


typedef int ULONG ;
struct TYPE_4__ {int * Buffer; } ;
struct TYPE_6__ {scalar_t__ NextEntryDelta; TYPE_2__* Threads; TYPE_1__ ProcessName; } ;
struct TYPE_5__ {int StartAddress; } ;
typedef scalar_t__ PUCHAR ;
typedef int PSYSTEM_THREAD_INFORMATION ;
typedef TYPE_3__* PSYSTEM_PROCESS_INFORMATION ;
typedef scalar_t__ (* PQUERYSYSTEM ) (int ,int *,int,int *) ;
typedef int PCWSTR ;
typedef scalar_t__ NTSTATUS ;
typedef int * LPVOID ;
typedef int DWORD ;


 scalar_t__ GetProcAddress (int ,char*) ;
 int LoadLibrary (char*) ;
 int NT_SUCCESS (scalar_t__) ;
 scalar_t__ STATUS_INFO_LENGTH_MISMATCH ;
 int SystemProcessesAndThreadsInformation ;
 int free (int *) ;
 int * malloc (int) ;
 int printf (char*,...) ;
 int wcsicmp (int *,char*) ;

ULONG GetCsrssThread()
{
 ULONG cbBuffer = 0x5000;
 ULONG tPointer;
    LPVOID pBuffer = ((void*)0);
    NTSTATUS Status;
 PCWSTR pszProcessName;
 DWORD junk;
 ULONG ThreadCount;
 int i=0,b=0;

 PQUERYSYSTEM NtQuerySystemInformation;
 PSYSTEM_THREAD_INFORMATION pThreads;
 PSYSTEM_PROCESS_INFORMATION pInfo ;

 NtQuerySystemInformation = (PQUERYSYSTEM) GetProcAddress( LoadLibrary( "ntdll.dll" ),
              "NtQuerySystemInformation" );


 do
    {
        pBuffer = malloc(cbBuffer);
        if (pBuffer == ((void*)0))
        {
            printf(("Not enough memory\n"));
           break;
        }

        Status = NtQuerySystemInformation(
                    SystemProcessesAndThreadsInformation,
                    pBuffer, cbBuffer, ((void*)0));

        if (Status == STATUS_INFO_LENGTH_MISMATCH)
        {
            free(pBuffer);
            cbBuffer *= 2;
        }
        else if (!NT_SUCCESS(Status))
        {
   printf("NtQuerySystemInformation Error! ");
            free(pBuffer);
        }

    } while (Status == STATUS_INFO_LENGTH_MISMATCH);


 pInfo = (PSYSTEM_PROCESS_INFORMATION)pBuffer;

    for (;;)
    {


  if (pInfo->NextEntryDelta == 0)
   break;
  if(pInfo->ProcessName.Buffer!=((void*)0) &&
        !wcsicmp(pInfo->ProcessName.Buffer,L"csrss.exe"))
  {

   printf("\n[%ws]  \n\n", pInfo->ProcessName.Buffer);
   printf("5 addresses for testing purposes\n\n");
        for(b=0;b<5;b++)
           {
             printf("Thread %d -> 0x%x\n",b,pInfo->Threads[b].StartAddress);
           }
     tPointer=(ULONG)pInfo->Threads[1].StartAddress;
        }
  pInfo = (PSYSTEM_PROCESS_INFORMATION)(((PUCHAR)pInfo)
      + pInfo->NextEntryDelta);
    }

    free(pBuffer);
    return tPointer;
}
