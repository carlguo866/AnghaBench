
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_6__ TYPE_2__ ;
typedef struct TYPE_5__ TYPE_1__ ;


typedef scalar_t__ (* _NtQuerySystemInformation ) (int ,TYPE_2__*,int,int*) ;
typedef size_t ULONG ;
struct TYPE_6__ {size_t NumberOfHandles; TYPE_1__* Handles; } ;
struct TYPE_5__ {int ProcessId; int Handle; int Object; } ;
typedef int QWORD ;
typedef TYPE_2__* PSYSTEM_HANDLE_INFORMATION ;
typedef int PSYSTEM_HANDLE ;
typedef int HANDLE ;
typedef int DWORD ;
typedef int BOOL ;


 int FALSE ;
 int GetLastError () ;
 int GetModuleHandle (char*) ;
 scalar_t__ GetProcAddress (int ,char*) ;
 int GetProcessHeap () ;
 scalar_t__ HeapAlloc (int ,int ,int) ;
 int HeapFree (int ,int ,TYPE_2__*) ;
 int OpenProcessToken (int,int ,int*) ;
 scalar_t__ STATUS_INFO_LENGTH_MISMATCH ;
 int SystemHandleInformation ;
 int TOKEN_QUERY ;
 int printf (char*,...) ;

QWORD TokenAddressCurrentProcess(HANDLE hProcess, DWORD MyProcessID)
{
    _NtQuerySystemInformation NtQuerySystemInformation;
    PSYSTEM_HANDLE_INFORMATION pSysHandleInfo;
    ULONG i;
    PSYSTEM_HANDLE pHandle;
    QWORD TokenAddress = 0;
    DWORD nSize = 4096;
    DWORD nReturn;
    BOOL tProcess;
    HANDLE hToken;


    if ((tProcess = OpenProcessToken(hProcess, TOKEN_QUERY, &hToken)) == FALSE)
    {
        printf("\n[-] OpenProcessToken() failed (%d)\n", GetLastError());
        return -1;
    }

    NtQuerySystemInformation = (_NtQuerySystemInformation)GetProcAddress(GetModuleHandle("ntdll.dll"), "NtQuerySystemInformation");

    if (!NtQuerySystemInformation)
    {
        printf("[-] Unable to resolve NtQuerySystemInformation\n\n");
        return -1;
    }

    do
    {
        nSize += 4096;
        pSysHandleInfo = (PSYSTEM_HANDLE_INFORMATION) HeapAlloc(GetProcessHeap(), 0, nSize);
    } while (NtQuerySystemInformation(SystemHandleInformation, pSysHandleInfo, nSize, &nReturn) == STATUS_INFO_LENGTH_MISMATCH);

    printf("\n[i] Current process id %d and token handle value %u", MyProcessID, hToken);

    for (i = 0; i < pSysHandleInfo->NumberOfHandles; i++)
    {

        if (pSysHandleInfo->Handles[i].ProcessId == MyProcessID && pSysHandleInfo->Handles[i].Handle == hToken)
        {
            TokenAddress = pSysHandleInfo->Handles[i].Object;
        }
    }

    HeapFree(GetProcessHeap(), 0, pSysHandleInfo);
    return TokenAddress;
}
