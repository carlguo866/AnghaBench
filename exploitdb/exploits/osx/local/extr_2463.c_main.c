
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;






struct rlimit {int dummy; } ;
typedef int mach_port_t ;


 int EXCEPTION_STATE_IDENTITY ;
 int EXC_MASK_BAD_ACCESS ;
 int MACH_MSG_TYPE_MAKE_SEND ;
 int MACH_PORT_RIGHT_RECEIVE ;
 int PPC_THREAD_STATE ;
 int RLIMIT_STACK ;
 int exc_server ;
 int execl (char*,char*,int *) ;
 scalar_t__ fork () ;
 int mach_msg_server_once (int ,int,int ,int ) ;
 int mach_port_allocate (int ,int ,int *) ;
 int mach_port_insert_right (int ,int ,int ,int ) ;
 int mach_task_self () ;
 int setrlimit (int ,struct rlimit*) ;
 int task_set_exception_ports (int ,int ,int ,int ,int ) ;
 int wait (int *) ;

int main(void) {
 mach_port_t self = mach_task_self(), exc;
 mach_port_allocate(self, MACH_PORT_RIGHT_RECEIVE, &exc);
 mach_port_insert_right(self, exc, exc, MACH_MSG_TYPE_MAKE_SEND);
 task_set_exception_ports(self, EXC_MASK_BAD_ACCESS, exc,
   EXCEPTION_STATE_IDENTITY, PPC_THREAD_STATE);

 if (fork()) {
  mach_msg_server_once(exc_server, 512, exc, 0);
  wait(((void*)0));
 } else {
  static struct rlimit rl;
  setrlimit(RLIMIT_STACK, &rl);
         execl("/usr/bin/chsh", "chsh", ((void*)0));
 }

 return 0;
}
