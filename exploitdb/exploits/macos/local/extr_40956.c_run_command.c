
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_3__ TYPE_1__ ;


struct TYPE_3__ {char __rip; char __rdi; char __rsi; char __rdx; } ;
typedef TYPE_1__ x86_thread_state64_t ;
typedef char uint64_t ;
typedef int thread_state_t ;
typedef int state ;
typedef char mach_vm_address_t ;
typedef int mach_port_t ;
typedef int mach_msg_type_number_t ;
typedef scalar_t__ kern_return_t ;
typedef int argv_contents ;


 scalar_t__ KERN_SUCCESS ;
 int MACH_PORT_NULL ;
 int VM_FLAGS_ANYWHERE ;
 scalar_t__ execve ;
 char* mach_error_string (scalar_t__) ;
 scalar_t__ mach_vm_allocate (int ,char*,int,int ) ;
 scalar_t__ mach_vm_write (int ,char,char*,int) ;
 int memset (TYPE_1__*,int ,int) ;
 int printf (char*,...) ;
 int strlen (char*) ;
 scalar_t__ thread_create_running (int ,int ,int ,int ,int *) ;
 int x86_THREAD_STATE64 ;
 int x86_THREAD_STATE64_COUNT ;

void run_command(mach_port_t target_task, char* command) {
  kern_return_t err;


  mach_vm_address_t command_addr = 0;
  err = mach_vm_allocate(target_task,
                         &command_addr,
                         0x1000,
                         VM_FLAGS_ANYWHERE);

  if (err != KERN_SUCCESS) {
    printf("mach_vm_allocate: %s\n", mach_error_string(err));
    return;
  }

  printf("allocated command at %zx\n", command_addr);
  uint64_t bin_bash = command_addr;
  uint64_t dash_c = command_addr + 0x10;
  uint64_t cmd = command_addr + 0x20;
  uint64_t argv = command_addr + 0x800;

  uint64_t argv_contents[] = {bin_bash, dash_c, cmd, 0};

  err = mach_vm_write(target_task,
                      bin_bash,
                      "/bin/bash",
                      strlen("/bin/bash") + 1);

  err = mach_vm_write(target_task,
                      dash_c,
                      "-c",
                      strlen("-c") + 1);

  err = mach_vm_write(target_task,
                      cmd,
                      command,
                      strlen(command) + 1);

  err = mach_vm_write(target_task,
                      argv,
                      argv_contents,
                      sizeof(argv_contents));

  if (err != KERN_SUCCESS) {
    printf("mach_vm_write: %s\n", mach_error_string(err));
    return;
  }


  mach_port_t new_thread = MACH_PORT_NULL;
  x86_thread_state64_t state;
  mach_msg_type_number_t stateCount = x86_THREAD_STATE64_COUNT;

  memset(&state, 0, sizeof(state));


  state.__rip = (uint64_t)execve;
  state.__rdi = (uint64_t)bin_bash;
  state.__rsi = (uint64_t)argv;
  state.__rdx = (uint64_t)0;

  err = thread_create_running(target_task,
                              x86_THREAD_STATE64,
                              (thread_state_t)&state,
                              stateCount,
                              &new_thread);

  if (err != KERN_SUCCESS) {
    printf("thread_create_running: %s\n", mach_error_string(err));
    return;
  }

  printf("done?\n");
}
